---
import Group from './Group.astro';
---

<Group />
<script>
	import { getCurrentViewTransition } from '@vtbag/utensil-drawer/may-start-view-transition';
	import type { Group } from './group';
	import { addBlinds } from './blinds';

	class ICGroupList extends HTMLElement {
		#animations: Animation[] = [];
		#dirty = false;
		#observer?: ResizeObserver;
		cards: Map<string, VtbagIcGroupElement>;
		#resizeToggle = false;
		#scope?: VtbagIcScopeElement;

		constructor() {
			super();
			this.cards = new Map();
		}
		connectedCallback() {
			this.#scope = this.closest<VtbagIcScopeElement>('vtbag-ic-scope')!;

			this.#observer = new ResizeObserver(() => {
				if (this.#resizeToggle || getCurrentViewTransition()) {
					return;
				}
				this.#resizeToggle = true;
				requestAnimationFrame(() => {
					addBlinds(this, 'vtbag-ic-group', 'nameless-group', '' + this.#scope!.scopeId, 'blind');
					this.#resizeToggle = false;
				});
			});
			this.#observer.observe(this);
			this.render();
		}

		disconnectedCallback() {
			this.#observer?.disconnect();
		}

		get animations() {
			return this.#animations;
		}

		set animations(value: Animation[]) {
			this.#animations = value;
			this.#dirty = true;
			this.render();
		}

		async render() {
			if (this.isConnected && this.#dirty) {
				this.#dirty = false;
//todo simplify
				const groups = this.closest<VtbagIcAnimationsElement>('vtbag-ic-animations')!.groupMaps.get(this.#scope!.element)!;
					
				this.replaceChildren();

				const newGroupAnimations = new Map<string, Animation[]>();
				this.#animations.forEach((animation) => {
					const groupName = (animation.effect as any as KeyframeEffect).pseudoElement?.replace(
						/::view-transition.*\((.*)\)/,
						'$1'
					);
					if (groupName) {
						let groupAnimations = newGroupAnimations.get(groupName);
						if (!groupAnimations) {
							groupAnimations = [];
							newGroupAnimations.set(groupName, groupAnimations);
						}
						groupAnimations.push(animation);
					}
				});

				newGroupAnimations.forEach((groupAnimations, groupName) => {
					if (groupName === '::view-transition') {
						// todo: push animation to pseudo-element
					} else {
						let group = groups.get(groupName);
						this.refreshGroup(group, groupAnimations);
					}
				});
				this.sort(
					this.#scope!.querySelector<HTMLInputElement>('input[value="alpha"]')?.checked
						? 'alpha'
						: 'paint-order'
				);
			}
		}

		sort(by: 'alpha' | 'paint-order') {
			const children = [...this.children] as VtbagIcGroupElement[];
			for (let idx = children.length - 1; idx >= 0; idx--) {
				const g = children[idx];
				if (!g.name) {
					children.splice(idx, 1);
					g.remove();
				}
			}
			if (children.length === 0) return;
			const sorted = children.sort((a, b) => {
				const ag = a as VtbagIcGroupElement;
				const bg = b as VtbagIcGroupElement;
				return by === 'paint-order'
					? ag.group.preOrder - bg.group.preOrder
					: ag.name.replace(/^-vtbag-/, '').localeCompare(bg.name.replace(/^-vtbag-/, ''));
			});
			// @ts-ignore
			if ('moveBefore' in Element.prototype) sorted.forEach((s) => this.moveBefore(s, null));
			else sorted.forEach((s) => this.appendChild(s));

			addBlinds(this, 'vtbag-ic-group', 'nameless-group', '' + this.#scope!.scopeId, 'blind');
		}
		private refreshGroup(group: Group, animations: Animation[]) {
			let card = this.cards.get(group.name)!;
			if (!card) {
				this.insertAdjacentHTML('beforeend', `<vtbag-ic-group></vtbag-ic-group>`);
				card = this.lastElementChild! as VtbagIcGroupElement;
				card.group = group;
				card.animations = animations;
				this.cards.set(group.name, card);
			}
			if (
				card.animations?.length !== animations.length ||
				card.animations.some((a, i) => a !== animations[i])
			) {
				card.animations = animations;
			}
		}
	}
	if (!customElements.get('vtbag-ic-group-list'))
		customElements.define('vtbag-ic-group-list', ICGroupList);
</script>
