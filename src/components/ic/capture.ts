import { namedElements } from "@/css";
import { getElementSelector } from "./element-selector";
import { effectiveZIndex } from "./stacking-context";

type Node = {
  viewTransitionName: string;
  viewTransitionGroup?: string;
  viewTransitionClass?: string;
  style: CSSStyleDeclaration;
  element: Element;
  pseudoElement?: string;
  zIndex?: number;
  children: Node[];
};


const ids = new WeakMap<Element, string>();
let idCount = 0;

export function capture(e: Event) {

  let sheet = '';
  const seen = new Set<string>();
  const elementMap = new Map<Element, Node>();
  const groups: Node[] = [];

  const transitionRoot = (e as CustomEvent).detail.viewTransition.transitionRoot
    ?? top!.__vtbag.ic2!.iframe!.contentDocument?.documentElement;

  const { elements: named } = namedElements(transitionRoot);

  let rootNode: Node = { viewTransitionName: 'none', element: transitionRoot, style: getComputedStyle(transitionRoot), children: [] };
  elementMap.set(transitionRoot, rootNode);

  named.forEach(({ element, pseudoElement }) => {
    const path = getElementSelector(element);
    // element.dataset.vtbagIcId = path;
    const key = path + (pseudoElement ? pseudoElement : '');
    if (seen.has(key)) return;
    seen.add(key);

    const style = getComputedStyle(element, pseudoElement);
    if (style.viewTransitionName === 'none') return;
    if (style.display === "none") return;

    const potentiallyRenamed = renameAutoGeneratedNames();
    addBackLink();

    const node = {
      element, pseudoElement,
      viewTransitionName: potentiallyRenamed,
      viewTransitionGroup: style.viewTransitionGroup,
      viewTransitionClass: style.viewTransitionClass,
      style,
      children: []
    };
    groups.push(node);
    if (!pseudoElement) elementMap.set(element, node);


    function renameAutoGeneratedNames() {
      const name = style.viewTransitionName;
      if (name === 'match-element' || (name === 'auto' && !element.id)) {
        let id = ids.get(element);
        if (!id) {
          id = `-vtbag-${name}-${++idCount}`;
          ids.set(element, id);
        }
        sheet += `${key} { view-transition-name: ${id} !important}\n`;
        return id;
      }
      return name;
    }



    function addBackLink() {
      const withBackLink = (style.backdropFilter !== 'none' ? style.backdropFilter + ' ' : '') +
        `url(#vtbag-ic-${key})`;
      sheet += `${key} { backdrop-filter: ${withBackLink}}\n`;
    }


  });

  rootNode = elementMap.get(transitionRoot)!;
  groups.forEach(linkToParent);
  sort(rootNode);

  paintOrder(rootNode, 0);

  top!.__vtbag.ic2!.iframe!.contentDocument!.body.insertAdjacentHTML(
    `beforeend`,
    `<style id="vtbag-ic-temp-style">${sheet}</style>`
  );

  function linkToParent(node: Node) {
    if (node.style?.contain.includes("view-transition")) return;
    if (node.pseudoElement) {
      let parent = elementMap.get(node.element);
      if (parent) {
        if (!parent.style?.contain.includes("view-transition")) {
          parent.children.push(node);
          node.zIndex = effectiveZIndex(node.element, node.style, parent.style);
        }
        return;
      } else {
        const parentStyle = getComputedStyle(node.element);
        parent = { children: [], element: node.element, viewTransitionName: 'none', style: parentStyle };
        elementMap.set(node.element, parent);
        if (parentStyle.contain.includes("view-transition")) return;

        parent.children.push(node);
        elementMap.set(node.element, parent);
        node = parent;
        // fall through 
      }
    }
    let me = node;
    let current = node.element;
    while (current !== transitionRoot) {
      const parent = elementMap.get(current.parentElement!);
      if (parent) {
        if (!parent.style?.contain.includes("view-transition")) {
          parent.children.push(me);
          node.zIndex = effectiveZIndex(node.element, node.style, parent.style);
        }
        return;
      }
      current = current.parentElement!;
      const parentStyle = getComputedStyle(current);
      const newParent: Node = { children: [], element: current, style: parentStyle, viewTransitionName: 'none' };
      elementMap.set(current, newParent);
      if (parentStyle.contain.includes("view-transition")) return;
      newParent.children.push(me);
      me = newParent;
    }
  }

  function sort(node: Node) {
    node.children.forEach(sort);
    node.children.sort((a, b) => a === b ? 0 : (a.element.compareDocumentPosition(b.element) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1));
    for (let i = 0; i < node.children.length - 1; ++i) {
      const pseudo = node.children[i].pseudoElement;
      if (pseudo)
        if (pseudo === '::after')
          node.children.push(node.children.splice(i, 1)[0]);
        else
          node.children.unshift(node.children.splice(i, 1)[0]);
    }
    node.children.sort((a, b) => a.zIndex! - b.zIndex!);
  }
}

function paintOrder(node: Node, order: number): number {
  if (node.viewTransitionName !== "none") console.log(++order, node.viewTransitionName);
  node.children.forEach(child => order = paintOrder(child, order));
  return order;
}