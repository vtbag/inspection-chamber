<script>
	import { color, type Group } from './group';
	import { key } from './scope.ts';
	import { mayStartViewTransition } from '@vtbag/utensil-drawer/may-start-view-transition';

	class ICPseudo extends HTMLElement {
		#computedStyle: CSSStyleDeclaration | undefined;
		#dirty = false;
		#animations: Animation[] = [];

		constructor() {
			super();
		}

		set animations(value: Animation[]) {
			if (value.some((a) => !this.#animations.includes(a))) {
				this.#animations = [...new Set<Animation>([...this.#animations, ...value])];

				this.#dirty = true;
				this.render();
			}
		}
		connectedCallback() {
			this.render();
		}

		static get observedAttributes() {
			return ['name'];
		}

		get exists() {
			return this.#computedStyle?.width !== 'auto';
		}

		attributeChangedCallback(_name: string, oldValue: string, newValue: string) {
			if (oldValue !== newValue) {
				this.#dirty = true;
				this.render();
			}
		}

		render() {
			if (this.isConnected && this.#dirty) {
				this.#dirty = false;

				let icScope;
				let groupElement;
				let name = this.getAttribute('name');
				if (name === '::view-transition') {
					icScope = this.closest('vtbag-ic-scope') as VtbagIcScopeElement;
				} else {
					groupElement = this.closest('vtbag-ic-group') as VtbagIcGroupElement;
					name = `::view-transition-${name}(${CSS.escape(groupElement.name)})`;
					icScope = groupElement.scope;
				}
				const scope = icScope!.element;
				// todo: simplify
				this.#computedStyle = scope?.ownerDocument.defaultView?.getComputedStyle(scope, name);

				// potentially "slotted" elements

				const hidden = scope.ownerDocument.body.querySelector(`#vtbag-vis-${CSS.escape(name)}`);
				const framed = scope.ownerDocument.body.querySelector(`#vtbag-frame-${CSS.escape(name)}`);
				this.insertAdjacentHTML(
					'afterbegin',
					`<span class="pseudo-head"><span class="name">${this.getAttribute('name')?.replace('image-pair', 'pair').replace('group-children', 'children') || '::view-transition'}</span>
					<label class="toggle frame ${this.getAttribute('name')}"><input type="checkbox" style="position: absolute; opacity: 0; pointer-events: none;" ${framed ? 'checked' : ''}>ðŸ–½</label><label class="toggle visibility">
	<input type="checkbox" style="position: absolute; opacity: 0; pointer-events: none;" ${hidden ? '' : 'checked'}>
	<svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	<use href="#icon-eye-on"/></svg></label>
	${
		this.getAttribute('name') === 'group'
			? `<label class="toggle solo"><input type="checkbox" style="position: absolute; opacity: 0; pointer-events: none;">s
		</label>`
			: ''
	}</span>
  `
				);
				hidden && ((this.children[1] as HTMLDivElement).style.display = 'none');
				frame(this, icScope, name);
				visibility(this, scope, name);
				solo(this);
				groupChildren(this, scope, groupElement!);
			}
		}
	}

	if (!customElements.get('vtbag-ic-pseudo')) customElements.define('vtbag-ic-pseudo', ICPseudo);

	function frame(pseudo: ICPseudo, icScope: VtbagIcScopeElement, name: string) {
		pseudo.querySelector<HTMLInputElement>('.frame input')?.addEventListener('click', (e) => {
			if ((e.target as HTMLElement).tagName !== 'INPUT') return;
			const checkbox = e.target as HTMLInputElement;

			const kind = pseudo.getAttribute('name');

			const color =
				kind === 'group'
					? 'var(--vtbag-ic-group-color)'
					: kind === 'old'
						? 'darkslateblue'
						: kind === 'new'
							? 'darkolivegreen'
							: kind === 'image-pair'
								? 'darkgoldenrod'
								: 'darkslategray';
								
			const thickness =
				kind === 'group'
					? 4
					: kind === 'old'
						? 2
						: kind === 'new'
							? 2
							: kind === 'image-pair'
								? 1
								: 3;

			icScope.element.ownerDocument.body
				.querySelector(`#vtbag-frame-${CSS.escape(name)}`)
				?.remove();
			if (checkbox.checked) {
				icScope.element.ownerDocument.body.insertAdjacentHTML(
					'beforeend',
					`<style id="vtbag-frame-${name}">${name} { outline: ${thickness}px solid ${color}; outline-offset:-${thickness}px; box-shadow: 0 0 ${thickness}px ${thickness}px  ${color}}</style>`
				);
			}
			pseudo.dispatchEvent(new CustomEvent('resync', { bubbles: true }));
			pseudo.dispatchEvent(new CustomEvent('frame-toggle', { bubbles: true }));
		});
	}

	function visibility(pseudo: ICPseudo, scope: HTMLElement, name: string) {
		pseudo.querySelector<HTMLInputElement>('.visibility input')!.addEventListener('click', (e) => {
			const checkbox = e.target as HTMLInputElement;
			const use = checkbox.nextElementSibling!.querySelector('use')!;
			const checked = checkbox.checked;
			use.href.baseVal = checked ? '#icon-eye-on' : '#icon-eye-off';
			scope.ownerDocument.body.querySelector(`#vtbag-vis-${CSS.escape(name)}`)?.remove();
			if (!checked) {
				scope.ownerDocument.body.insertAdjacentHTML(
					'beforeend',
					`<style id="vtbag-vis-${name}">${name} { opacity: 0}</style>`
				);
			}
			pseudo.dispatchEvent(new CustomEvent('resync', { bubbles: true }));
			if (!checked && pseudo.querySelector<HTMLInputElement>('.solo input')?.checked) {
				pseudo.querySelector<HTMLInputElement>('.solo input')!.click();
			}
			const inner = checkbox.closest('vtbag-ic-pseudo')?.children[1] as HTMLDivElement;
			inner &&
				mayStartViewTransition(
					{
						update: () => {
							inner.style.display = checked ? '' : 'none';
							pseudo.dispatchEvent(new CustomEvent('frame-toggle', { bubbles: true }));
						},
						types: ['visibility-toggle'],
					},
					{ collisionBehavior: 'chaining', useTypesPolyfill: 'always' }
				);
		});
	}

	function solo(pseudo: ICPseudo) {
		pseudo.querySelector<HTMLInputElement>('.solo input')?.addEventListener('click', (e) => {
			if ((e.target as HTMLElement).tagName !== 'INPUT') return;
			const checkbox = e.target as HTMLInputElement;

			document
				.querySelectorAll<HTMLInputElement>('.visibility input:not(:checked)')
				.forEach((h) => h.click());

			const solos = document.querySelectorAll<HTMLInputElement>(
				`vtbag-ic-pseudo .solo input:checked`
			);

			if (solos.length === 0) return;

			solos.forEach((v) => v !== checkbox && ((v.checked = false), v.removeAttribute('checked')));

			const me = checkbox.closest('vtbag-ic-pseudo');
			document
				.querySelectorAll<VtbagIcPseudoElement>('vtbag-ic-pseudo[name="group"]')
				.forEach(
					(i) =>
						i !== me && i.querySelector<HTMLInputElement>('.pseudo-head .visibility input')!.click()
				);
		});
	}

	function groupChildren(pseudo: ICPseudo, scope: HTMLElement, groupElement: VtbagIcGroupElement) {
		if (pseudo.getAttribute('name') === 'group-children') {
			const group = pseudo
				.closest<VtbagIcAnimationsElement>('vtbag-ic-animations')!
				.groupMaps.get(key(scope))
				?.get(groupElement!.name) as Group;
			let html = '<div name="children">';

			group.children.forEach(
				(g) =>
					(html += `<button data-group="${g.preOrder}" style="border: 2px solid ${color(group)}">${g.name.replace(
						/-vtbag-match-element-([0-9]+)/,
						(_, num) => `match-element<sup>(${num})</sup>`
					)}</button>`)
			);
			html += '</div>';
			pseudo.insertAdjacentHTML('beforeend', html);
		}
	}
</script>
