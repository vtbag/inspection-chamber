---
import Group from './Group.astro';
---

<Group />
<script>
	import { getCurrentViewTransition } from '@vtbag/utensil-drawer/may-start-view-transition';
	import type { Group } from './group';
	import { key } from './scope';

	class ICGroupList extends HTMLElement {
		#initialized = false;
		#animations: Animation[] = [];
		#dirty = false;
		#observer?: ResizeObserver;
		cards: Map<string, VtbagIcGroupElement>;
		#requestedResort = false;
		#scope?: VtbagIcScopeElement;

		constructor() {
			super();
			this.cards = new Map();
		}
		connectedCallback() {
			if (!this.#initialized) {
				this.#initialized = true;
			}
			this.#scope = this.closest<VtbagIcScopeElement>('vtbag-ic-scope')!;

			this.#observer = new ResizeObserver(() => {
				if (this.#requestedResort || getCurrentViewTransition()) {
					return;
				}
				this.#requestedResort = true;

				requestAnimationFrame(() => {
					this.sort(
						this.#scope!.querySelector<HTMLInputElement>('input[value="alpha"]')?.checked
							? 'alpha'
							: 'paint-order'
					);
					this.#requestedResort = false;
				});
			});
			this.#observer.observe(this);
			this.render();
		}

		disconnectCallback() {
			this.#observer?.disconnect();
		}

		get animations() {
			return this.#animations;
		}

		set animations(value: Animation[]) {
			this.#animations = value;
			this.#dirty = true;
			this.render();
		}

		async render() {
			if (this.isConnected && this.#dirty) {
				this.#dirty = false;

				
				const groups = this.closest<VtbagIcAnimationsElement>('vtbag-ic-animations')!.groupMaps.get(
					key(this.#scope!.element)
				)!;

				this.replaceChildren();

				const newGroupAnimations = new Map<string, Animation[]>();
				this.#animations.forEach((animation) => {
					const groupName = (animation.effect as any as KeyframeEffect).pseudoElement?.replace(
						/::view-transition.*\((.*)\)/,
						'$1'
					);
					if (groupName) {
						let groupAnimations = newGroupAnimations.get(groupName);
						if (!groupAnimations) {
							groupAnimations = [];
							newGroupAnimations.set(groupName, groupAnimations);
						}
						groupAnimations.push(animation);
					}
				});

				newGroupAnimations.forEach((groupAnimations, groupName) => {
					let group = groups.get(groupName);
					this.refreshGroup(group, groupAnimations);
				});
				this.cards.forEach((groupElement, groupName) => {
					if (!newGroupAnimations.has(groupName)) {
						groupElement.remove();
						this.cards.delete(groupName);
					}
				});

				this.sort(
					this.#scope!.querySelector<HTMLInputElement>('input[value="alpha"]')?.checked
						? 'alpha'
						: 'paint-order'
				);
			}
		}

		sort(by: 'alpha' | 'paint-order') {
			const children = [...this.children] as VtbagIcGroupElement[];
			for (let idx = children.length - 1; idx >= 0; idx--) {
				const g = children[idx];
				if (!g.name) {
					children.splice(idx, 1);
					g.remove();
				}
			}
			if (children.length === 0) return;
			children
				.sort((a, b) => {
					const ag = a as VtbagIcGroupElement;
					const bg = b as VtbagIcGroupElement;
					return by === 'paint-order'
						? ag.group.preOrder - bg.group.preOrder
						: ag.name.replace(/^-vtbag-/, '').localeCompare(bg.name.replace(/^-vtbag-/, ''));
				})
				.forEach((c) => this.appendChild(c));
			const container = this.getBoundingClientRect();
			let prev = children[0]?.getBoundingClientRect();
			const fix = [];
			let columnWidth = prev.width;
			children.forEach((g, idx) => {
				const current = g.getBoundingClientRect();
				columnWidth = Math.min(columnWidth, current.width);
				if (idx > 0) {
					if (current.top > prev.bottom) fix[idx - 1] = prev;
				}
				prev = current;
			});

			fix[children.length - 1] = prev;
			let cnt = 0;
			for (let i = fix.length - 1; i >= 0; --i) {
				const last = fix[i];
				if (last) {
					const span = ~~((container.right - last.right) / columnWidth);
					if (span > 0) {
						this.children[i].insertAdjacentHTML(
							'afterend',
							`<vtbag-ic-group style="grid-column: span ${span}; view-transition-name: p-${this.#scope!.scopeId}-${cnt++}; view-transition-class: blind"></vtbag-ic-group>`
						);
					}
				}
			}
		}
		private refreshGroup(group: Group, animations: Animation[]) {
			let card = this.cards.get(group.name)!;
			if (!card) {
				this.insertAdjacentHTML('beforeend', `<vtbag-ic-group></vtbag-ic-group>`);
				card = this.lastElementChild! as VtbagIcGroupElement;
				card.group = group;
				card.animations = animations;
				this.cards.set(group.name, card);
			}
			if (
				card.animations?.length !== animations.length ||
				card.animations.some((a, i) => a !== animations[i])
			) {
				card.animations = animations;
			}
		}
	}
	if (!customElements.get('vtbag-ic-group-list'))
		customElements.define('vtbag-ic-group-list', ICGroupList);
</script>
