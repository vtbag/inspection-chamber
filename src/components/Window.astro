---
const { style } = Astro.props;
---

<div class="window" {style}>
	<div class="window-header" id="window-header">
		<div class="window-title">
			<slot name="title" />
		</div>
		<div class="window-controls">
			<button class="control-btn minimize" id="minimize-btn" title="Minimize">&lt;</button>
		</div>
	</div>
	<div class="window-content">
		<slot />
	</div>
	<div class="resize-handle edge n"></div>
	<div class="resize-handle edge s"></div>
	<div class="resize-handle edge e"></div>
	<div class="resize-handle edge w"></div>
	<div class="resize-handle corner nw"></div>
	<div class="resize-handle corner ne"></div>
	<div class="resize-handle corner sw"></div>
	<div class="resize-handle corner se"></div>
</div>

<style is:global>
	* {
		box-sizing: border-box;
	}
	:root {
		font-family: monospace;
		line-height: 1.6;
		font-weight: 400;
		color-scheme: dark light;
	}

	.window {
		pointer-events: all;
		position: fixed;
		width: var(--window-width, min(80vw, 300px));
		height: var(--window-height, min(80vh, 300px));
		left: var(--window-left, 50px);
		top: var(--window-top, 50px);
		background-color: black;
		border-radius: 12px;
		display: flex;
		flex-direction: column;
		overflow: clip;
		padding: 8px;
		/* backdrop-filter: blur(8px); */
		/* transition-behavior: allow-discrete; */
		/* transition-property: width, height, display; */
		/* transition-duration: 100ms; */
	}

	.window.minimized {
		height: 37px;
		width: 72px;
		border: 2px solid green;
		padding: 0;
	}
	:active-view-transition-type(minimize) {
		.window.minimized {
			border: none;
		}
	}

	.window.window-changing {
		transition: none;
	}

	.window.window-hidden {
		display: none;
	}

	.window.window-visible {
		display: flex;
	}
	.window-header {
		background-image: linear-gradient(to bottom, #9994, #7774);
		border-bottom: 4px solid light-dark(white, black);
		border-radius: 8px 8px 0 0;
		display: flex;
		align-items: center;
		justify-content: space-between;
		cursor: move;
		user-select: none;
		padding: 0.2em 0.5em;
	}

	.window-title {
		font-weight: 600;
		font-size: 0.875rem;
		color: var(--text-primary);
	}

	.window-controls {
		display: flex;
		gap: 8px;
	}

	.control-btn {
		color: light-dark(#a86, #864);
		width: 20px;
		height: 20px;
		border-radius: 50%;
		border: none;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 12px;
		font-weight: bold;
	}

	.control-btn.minimize {
		background-color: light-dark(#ddd, #444);
		&:hover {
			background-color: #888;
		}
	}

	.window-content {
		width: 100%;
	}

	.window.minimized .window-content {
		height: 0;
		font-size: 0;
	}
	:is(.window.minimized, .window.window-changing) .resize-handle {
		display: none;
	}

	.resize-handle {
		position: absolute;
		background: transparent;
	}

	.resize-handle.corner {
		width: 12px;
		height: 12px;
	}

	.resize-handle.edge {
		background: transparent;
	}

	.resize-handle.n {
		top: 0;
		left: 0;
		right: 0;
		height: 8px;
		cursor: n-resize;
	}

	.resize-handle.s {
		bottom: 0;
		left: 0;
		right: 0;
		height: 8px;
		cursor: s-resize;
	}

	.resize-handle.e {
		top: 0;
		right: 0;
		bottom: 0;
		width: 8px;
		cursor: e-resize;
	}

	.resize-handle.w {
		top: 0;
		left: 0;
		bottom: 0;
		width: 8px;
		cursor: w-resize;
	}

	.resize-handle.nw {
		top: 0;
		left: 0;
		cursor: nw-resize;
	}

	.resize-handle.ne {
		top: 0;
		right: 0;
		cursor: ne-resize;
	}

	.resize-handle.sw {
		bottom: 0;
		left: 0;
		cursor: sw-resize;
	}

	.resize-handle.se {
		bottom: 0;
		right: 0;
		cursor: se-resize;
	}

	.resize-handle:hover {
		background: #5858;
	}
</style>

<script>
	import {
		mayStartViewTransition,
	} from '@vtbag/utensil-drawer/may-start-view-transition';

	const ANIM_TIMEOUT = 	1;
	interface DragState {
		isDragging: boolean;
		startX: number;
		startY: number;
		startLeft: number;
		startTop: number;
	}

	interface ResizeState {
		isResizing: boolean;
		startX: number;
		startY: number;
		startWidth: number;
		startHeight: number;
		startLeft: number;
		startTop: number;
		direction: string;
		longTap?: NodeJS.Timeout;
		snapshot?: NodeJS.Timeout;
	}

	function setupWindow() {
		const theWindow = document.querySelector('.window') as HTMLElement;
		const header = document.getElementById('window-header') as HTMLElement;
		const minimizeBtn = document.getElementById('minimize-btn') as HTMLElement;

		if (!theWindow || !header || !minimizeBtn) return;

		let dragState: DragState = {
			isDragging: false,
			startX: 0,
			startY: 0,
			startLeft: 0,
			startTop: 0,
		};

		let resizeState: ResizeState = {
			isResizing: false,
			startX: 0,
			startY: 0,
			startWidth: 0,
			startHeight: 0,
			startLeft: 0,
			startTop: 0,
			direction: '',
		};
		let isMinimized = false;
		let previousHeight = '';

		header.addEventListener('pointerdown', (e: PointerEvent) => {
			if ((e.target as HTMLElement).closest('.window-controls')) return;

			dragState.isDragging = true;
			dragState.startX = e.clientX;
			dragState.startY = e.clientY;

			const rect = theWindow.getBoundingClientRect();
			dragState.startLeft = rect.left;
			dragState.startTop = rect.top;

			document.addEventListener('pointermove', handleDrag);
			document.addEventListener('pointerup', stopDrag);
			header.setPointerCapture(e.pointerId);
			e.preventDefault();
		});

		function handleDrag(e: PointerEvent) {
			if (!dragState.isDragging) return;

			const deltaX = e.clientX - dragState.startX;
			const deltaY = e.clientY - dragState.startY;

			const newLeft = dragState.startLeft + deltaX;
			const newTop = dragState.startTop + deltaY;

			const finalLeft = Math.max(
				dragState.startLeft - dragState.startX,
				Math.min(newLeft, innerWidth - 20)
			);
			const finalTop = Math.max(
				dragState.startTop - dragState.startY,
				Math.min(newTop, innerHeight - 20)
			);

			theWindow.style.setProperty('--window-left', finalLeft + 'px');
			theWindow.style.setProperty('--window-top', finalTop + 'px');
			theWindow.classList.add('window-changing');
		}

		function stopDrag() {
			dragState.isDragging = false;
			theWindow.classList.remove('window-changing');
			document.removeEventListener('pointermove', handleDrag);
			document.removeEventListener('pointerup', stopDrag);
		}

		const resizeHandles = theWindow.querySelectorAll<HTMLDivElement>('.resize-handle');
		let iframe: HTMLIFrameElement | null = null;

		resizeHandles.forEach((handle) => {
			handle.addEventListener('pointerdown', (e: PointerEvent) => {
				if (isMinimized) return;

				resizeState.isResizing = true;
				resizeState.startX = e.clientX;
				resizeState.startY = e.clientY;
				resizeState.startWidth = theWindow.offsetWidth;
				resizeState.startHeight = theWindow.offsetHeight;
				resizeState.startLeft = theWindow.offsetLeft;
				resizeState.startTop = theWindow.offsetTop;
				resizeState.direction = (handle as HTMLElement).className.split(' ').pop() || '';
				iframe = theWindow.querySelector('iframe');
				iframe && initAnimation(iframe);

				document.addEventListener('pointermove', handleResize);
				document.addEventListener('pointerup', stopResize);
				resizeState.longTap = setTimeout(() => {
					resizeState.longTap = undefined;
					stopResize();
					dispatchEvent(new CustomEvent('longTap', { detail: { side: resizeState.direction } }));
				}, 500);
				e.preventDefault();
				e.stopPropagation();

				handle.setPointerCapture(e.pointerId);
			});
		});

		function initAnimation(iframe: HTMLIFrameElement) {
			const rect = iframe.getBoundingClientRect();
			iframe.style.flex = '0 0 auto';
			iframe.style.width = rect.width + 'px';
			iframe.style.height = rect.height + 'px';
			const bodyStyle = iframe!.contentDocument!.body.style;
			bodyStyle.width = rect.width + 'px';
			bodyStyle.height = rect.height + 'px';
			resizeState.snapshot = setTimeout(() => showAnimation(iframe), 500);
		}

		function showAnimation(iframe: HTMLIFrameElement) {
			if (!resizeState.snapshot) return;
			const oldRect = iframe.getBoundingClientRect();
			iframe.style.flex = '1 1 auto';
			iframe.style.width = '100%';
			iframe.style.height = '';
			const rect = iframe.getBoundingClientRect();
			iframe.style.width = Math.max(oldRect.width, rect.width) + 'px';
			iframe.style.height = Math.max(oldRect.height, rect.height) + 'px';
			iframe.style.flex = '0 0 auto';
			mayStartViewTransition(
				{
					update: async () => {
						const oldRect = iframe.contentDocument!.body.getBoundingClientRect();
						const bodyStyle = iframe!.contentDocument!.body.style;
						bodyStyle.width = rect.width + 'px';
						bodyStyle.height = rect.height + 'px';
					},
					types: ['window-resize'],
				},
				{ scope: iframe.contentDocument!, useTypesPolyfill: 'always', collisionBehavior: 'chaining' }
			).finished.then(() => {
				if (resizeState.snapshot) reInitAnimation(iframe, rect);
			});
		}

		function reInitAnimation(iframe: HTMLIFrameElement, rect: DOMRect) {
			const bodyStyle = iframe!.contentDocument!.body.style;
			iframe!.style.width = rect.width + 'px';
			iframe!.style.height = rect.height + 'px';
			bodyStyle.width = rect.width + 'px';
			bodyStyle.height = rect.height + 'px';
			resizeState.snapshot = setTimeout(() => showAnimation(iframe!), ANIM_TIMEOUT);
		}

		function handleResize(e: PointerEvent) {
			if (!resizeState.isResizing) return;

			const deltaX = Math.min(Math.max(2, e.clientX), innerWidth - 2) - resizeState.startX;
			const deltaY = Math.min(Math.max(2, e.clientY), innerHeight - 2) - resizeState.startY;
			if (resizeState.longTap && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
				clearTimeout(resizeState.longTap);
				resizeState.longTap = undefined;
			}
			let newWidth = resizeState.startWidth;
			let newHeight = resizeState.startHeight;
			let newLeft = resizeState.startLeft;
			let newTop = resizeState.startTop;

			const minWidth = 300;
			const minHeight = 250;

			switch (resizeState.direction) {
				case 'e':
					newWidth = Math.max(minWidth, resizeState.startWidth + deltaX);
					break;
				case 'w':
					newWidth = Math.max(minWidth, resizeState.startWidth - deltaX);
					newLeft = resizeState.startLeft + (resizeState.startWidth - newWidth);
					break;
				case 's':
					newHeight = Math.max(minHeight, resizeState.startHeight + deltaY);
					break;
				case 'n':
					newHeight = Math.max(minHeight, resizeState.startHeight - deltaY);
					newTop = resizeState.startTop + (resizeState.startHeight - newHeight);
					break;
				case 'se':
					newWidth = Math.max(minWidth, resizeState.startWidth + deltaX);
					newHeight = Math.max(minHeight, resizeState.startHeight + deltaY);
					break;
				case 'sw':
					newWidth = Math.max(minWidth, resizeState.startWidth - deltaX);
					newHeight = Math.max(minHeight, resizeState.startHeight + deltaY);
					newLeft = resizeState.startLeft + (resizeState.startWidth - newWidth);
					break;
				case 'ne':
					newWidth = Math.max(minWidth, resizeState.startWidth + deltaX);
					newHeight = Math.max(minHeight, resizeState.startHeight - deltaY);
					newTop = resizeState.startTop + (resizeState.startHeight - newHeight);
					break;
				case 'nw':
					newWidth = Math.max(minWidth, resizeState.startWidth - deltaX);
					newHeight = Math.max(minHeight, resizeState.startHeight - deltaY);
					newLeft = resizeState.startLeft + (resizeState.startWidth - newWidth);
					newTop = resizeState.startTop + (resizeState.startHeight - newHeight);
					break;
			}

			theWindow.style.setProperty('--window-width', newWidth + 'px');
			theWindow.style.setProperty('--window-height', newHeight + 'px');
			theWindow.style.setProperty('--window-left', newLeft + 'px');
			theWindow.style.setProperty('--window-top', newTop + 'px');

			theWindow.classList.add('window-changing');
		}

		function stopResize() {
			resizeState.isResizing = false;
			theWindow.classList.remove('window-changing');
			document.removeEventListener('pointermove', handleResize);
			document.removeEventListener('pointerup', stopResize);
			resizeState.longTap && clearTimeout(resizeState.longTap);
			resizeState.longTap = undefined;
			resizeState.snapshot && clearTimeout(resizeState.snapshot);
			resizeState.snapshot = undefined;
			const iframe = theWindow.querySelector('iframe');
			if (iframe) {
				iframe.style.flex = '1 1 auto';
				iframe.style.width = '100%';
				iframe.style.height = '';
				mayStartViewTransition(
					{
						update: () => {
							const bodyStyle = iframe!.contentDocument!.body.style;
							bodyStyle.width = '';
							bodyStyle.height = '';
						},
						types: ['window-resize'],
					},
					{
						collisionBehavior: 'chaining',
						useTypesPolyfill: 'always',
						scope: iframe.contentDocument!,
					}
				);
			}
		}

		minimizeBtn.addEventListener('click', () => {
			isMinimized = !isMinimized;

			const transition = mayStartViewTransition(
				{
					update: () => {
						if (isMinimized) {
							previousHeight = theWindow.style.getPropertyValue('--window-height') || '300px';
							theWindow.classList.add('minimized');
							minimizeBtn.innerHTML = '>';
							minimizeBtn.title = 'Restore';
						} else {
							theWindow.classList.remove('minimized');
							theWindow.style.setProperty('--window-height', previousHeight);
							minimizeBtn.innerHTML = '<';
							minimizeBtn.title = 'Minimize';
						}
					},
					types: ['minimize'],
				},
				{ collisionBehavior: 'chaining', useTypesPolyfill: 'always' }
			);
			transition.finished.then(() => {});
		});
	}

	// Initialize the window functionality
	setupWindow();
</script>
