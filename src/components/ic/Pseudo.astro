<script>
	import { color, gid, type Group } from './group';
	import { mayStartViewTransition } from '@vtbag/utensil-drawer/may-start-view-transition';
	import './toggle.css';
	import { minmax } from './minmax';

	const twinProperties = {
		position: '',
		top: '0px',
		left: '0px',
		bottom: '0px',
		right: '0px',
		width: '0px',
		height: '0px',
		translate: 'none',
		rotate: 'none',
		scale: 'none',
		transform: 'none',
		'transform-origin': '50% 50%',
		perspective: 'none',
		'box-sizing': 'content-box',
		'border-width': '0px',
		'border-radius': '0px',
		'z-index': 'auto',
	};

	const allProperties = Array.from(
		getComputedStyle(parent.document.querySelector('#default')!)
	).filter(
		(p) =>
			!p.startsWith('--vtbag-ic-') &&
			!p.includes('-start-start-') &&
			!p.includes('-start-end-') &&
			!p.includes('-end-start-') &&
			!p.includes('-end-end-') &&
			!p.includes('block-') &&
			!p.includes('inline-') &&
			!p.includes('-block') &&
			!p.includes('-inline')
	);

	class ICPseudo extends HTMLElement {
		#computedStyle: CSSStyleDeclaration | undefined;
		#animations: Animation[] | undefined;
		id = '';
		icParentPseudo?: VtbagIcPseudoElement;
		icGroup?: VtbagIcGroupElement;
		icScope?: VtbagIcScopeElement;
		#twin?: HTMLDivElement;
		static defaultStyles: CSSStyleDeclaration | undefined;

		constructor() {
			super();
		}

		connectedCallback() {
			this.render();
		}

		connectedMoveCallback() {}

		disconnectedCallback() {
			parent.__vtbag.ic2?.intersectionObserver?.unobserve(this.#twin!);
			this.#twin?.remove();
		}

		get exists() {
			return this.#computedStyle?.width !== 'auto';
		}

		get twin() {
			return this.#twin;
		}

		async computedStyleCompact(all = true) {
			const result: { key: string; value: string; defaultValue: string; priority: string }[] = [];

			let start = performance.now();

			for (const key of all ? allProperties : Object.keys(twinProperties!)) {
				await (async () => {
					let defaultValue = ICPseudo.defaultStyles!.getPropertyValue(key);
					const value = this.#computedStyle!.getPropertyValue(key);
					const priority = this.#computedStyle!.getPropertyPriority(key);
					if (performance.now() - start > 10) {
						await new Promise((r) => setTimeout(r));
						start = performance.now();
					}
					if (key === 'transform-origin' || key === 'perspective-origin') {
						// detect fitting absolute values for 50%, 50% default.
						const [w, h] = value.split(' ').map((v) => parseFloat(v) * 2);
						const w2 =
							parseFloat(this.#computedStyle!.width) +
							parseFloat(this.#computedStyle!.paddingLeft) +
							parseFloat(this.#computedStyle!.paddingRight) +
							parseFloat(this.#computedStyle!.borderLeftWidth) +
							parseFloat(this.#computedStyle!.borderRightWidth);
						const h2 =
							parseFloat(this.#computedStyle!.height) +
							parseFloat(this.#computedStyle!.paddingTop) +
							parseFloat(this.#computedStyle!.paddingBottom) +
							parseFloat(this.#computedStyle!.borderTopWidth) +
							parseFloat(this.#computedStyle!.borderBottomWidth);
						if (Math.abs(w - w2) < 2 && Math.abs(h - h2) < 2) defaultValue = value;
					}
					if (value !== defaultValue && (value === 'auto' || value === 'normal'))
						console.log(key, defaultValue, value);
					result.push({ key, value, defaultValue, priority });
				})();
			}
			return result;
		}

		name(escaped = false) {
			const name = this.getAttribute('name');
			if (name === '::view-transition') {
				return name;
			}
			return `::view-transition-${name}(${escaped ? CSS.escape(this.icGroup!.name) : this.icGroup!.name})`;
		}

		animations() {
			return (this.#animations ??=
				this.icScope?.animations.filter((a) => a.effect?.pseudoElement === this.name()) || []);
		}
		render() {
			if (this.isConnected) {
				const kind = this.getAttribute('name');
				this.icGroup = this.closest('vtbag-ic-group') as VtbagIcGroupElement;
				if (kind === '::view-transition') {
					this.icParentPseudo = undefined;
					this.icGroup = undefined;
					this.icScope = this.closest('vtbag-ic-scope') as VtbagIcScopeElement;
				} else {
					this.icParentPseudo =
						kind === 'group'
							? undefined
							: (this.parentElement!.closest('vtbag-ic-pseudo') as VtbagIcPseudoElement);

					this.icScope = this.icGroup.scope;
				}
				const scope = this.icScope.element;
				this.id = `${this.icScope.scopeId}-${gid(this.icGroup?.group)}-${kind}`;

				// todo: simplify
				this.#computedStyle = scope?.ownerDocument.defaultView?.getComputedStyle(
					scope,
					this.name(true)
				);

				const twins = parent.document.querySelector('#twins')!;
				const defaultDiv = twins.querySelector<HTMLDivElement>('#default')!;
				ICPseudo.defaultStyles = twins.ownerDocument.defaultView?.getComputedStyle(defaultDiv)!;

				// potentially "slotted" elements

				const framed = scope.ownerDocument.body.querySelector(`#vtbag-frame-${this.id}`);
				this.insertAdjacentHTML(
					'afterbegin',
					`<span class="pseudo-head"><span class="name">${this.getAttribute('name') || '::view-transition'}</span>
					<label class="toggle frame ${this.getAttribute('name')}"><input type="checkbox" ${framed ? 'checked' : ''}>ðŸ–½</label><label class="toggle visibility"><input type="checkbox" checked>â—Ž</label
						>${
							this.getAttribute('name') === 'group'
								? `<label class="toggle solo"><input type="checkbox">s</label>`
								: ''
						}</span>`
				);
				this.frame();
				this.visibility();
				this.solo();
				this.groupChildren();
			}
		}
		createTwin() {
			const twins = parent.document.querySelector<HTMLDivElement>('#twins')!;
			this.#twin = twins.ownerDocument.createElement('div')!;
			this.#twin.dataset.title = (this.icScope?.path ?? '') + this.name();
			this.dataset.link = this.#twin.dataset.title!;
			this.moveTwin();
			let parentPseudo = this.icParentPseudo || null;
			if (!parentPseudo) {
				const parentGroupName = this.icGroup?.group.parent?.name;
				if (parentGroupName) {
					if (this.icGroup?.group.parent?.parent) {
						const parentPseudoName =
							this.icScope!.path + '::view-transition-group-children(' + parentGroupName + ')';
						parentPseudo = this.icScope!.querySelector<VtbagIcPseudoElement>(
							`vtbag-ic-pseudo[data-link='${parentPseudoName}']`
						);
					} else {
						parentPseudo = this.parentElement!.closest<VtbagIcPseudoElement>(`vtbag-ic-pseudo`);
					}
				}
			}
			this.icParentPseudo = parentPseudo ?? undefined;
			(parentPseudo?.twin ?? twins).appendChild(this.#twin);
		}

		async moveTwin() {
			const properties = await this.computedStyleCompact(false);
			properties.forEach(({ key, value, defaultValue, priority }) => {
				this.#twin!.style.setProperty(key, value !== defaultValue ? value : '', priority);
			});
			if (
				this.icScope?.path !== ':root' &&
				this.#twin!.dataset.title === (this.icScope?.path ?? '') + '::view-transition'
			) {
				const rect = this.icScope!.element.getBoundingClientRect();
				this.#twin!.style.top = rect.top + 'px';
				this.#twin!.style.left = rect.left + 'px';
			}
		}
		frame() {
			this.querySelector<HTMLInputElement>('.frame input')?.addEventListener('click', (e) => {
				if ((e.target as HTMLElement).tagName !== 'INPUT') return;
				const checkbox = e.target as HTMLInputElement;
				const kind = this.getAttribute('name');

				const color =
					kind === 'group'
						? 'var(--vtbag-ic-group-color)'
						: kind === 'old'
							? 'darkslateblue'
							: kind === 'new'
								? 'darkolivegreen'
								: kind === 'image-pair'
									? 'darkgoldenrod'
									: 'darkslategray';

				const thickness =
					kind === 'group'
						? 3
						: kind === 'old'
							? 2
							: kind === 'new'
								? 2
								: kind === 'image-pair'
									? 1
									: 3;

				const key = `vtbag-frame-${this.id}`;
				this.icScope!.element.ownerDocument.body.querySelector('#' + key)?.remove();
				if (checkbox.checked) {
					this.icScope!.element.ownerDocument.body.insertAdjacentHTML(
						'beforeend',
						`<style id="${key}">${this.name(true)} { outline: ${thickness}px solid ${color}; outline-offset:-${thickness}px; box-shadow: 0 0 ${thickness}px ${thickness}px  ${color}}</style>`
					);
				}
				this.dispatchEvent(new CustomEvent('resync', { bubbles: true }));
				this.dispatchEvent(new CustomEvent('frame-toggle', { bubbles: true }));
			});
		}

		visibility() {
			const scope = this.icScope!.element;
			this.querySelector<HTMLInputElement>('.visibility input')!.addEventListener('click', (e) => {
				const checkbox = e.target as HTMLInputElement;
				const checked = checkbox.checked;
				scope.ownerDocument.body.querySelector(`#vtbag-vis-${this.id}`)?.remove();
				if (!checked) {
					scope.ownerDocument.body.insertAdjacentHTML(
						'beforeend',
						`<style id="vtbag-vis-${this.id}">${this.name(true)} { opacity: 0}</style>`
					);
				}
				this.dispatchEvent(new CustomEvent('resync', { bubbles: true }));
				if (!checked && this.querySelector<HTMLInputElement>('.solo input')?.checked) {
					this.querySelector<HTMLInputElement>('.solo input')!.click();
				}
				const inner = checkbox.closest('vtbag-ic-pseudo')?.children[1] as HTMLDivElement;
				inner &&
					mayStartViewTransition(
						{
							update: () => {
								inner.style.display = checked ? '' : 'none';
								this.dispatchEvent(new CustomEvent('frame-toggle', { bubbles: true }));
							},
							types: ['visibility-toggle'],
						},
						{ collisionBehavior: 'chaining', useTypesPolyfill: 'always' }
					);
			});
		}

		solo() {
			this.querySelector<HTMLInputElement>('.solo input')?.addEventListener('click', (e) => {
				if ((e.target as HTMLElement).tagName !== 'INPUT') return;
				const checkbox = e.target as HTMLInputElement;

				document
					.querySelectorAll<HTMLInputElement>('.visibility input:not(:checked)')
					.forEach((h) => h.click());

				const solos = document.querySelectorAll<HTMLInputElement>(
					`vtbag-ic-pseudo .solo input:checked`
				);

				if (solos.length === 0) return;

				solos.forEach((v) => v !== checkbox && ((v.checked = false), v.removeAttribute('checked')));

				const me = checkbox.closest('vtbag-ic-pseudo')!;
				document
					.querySelectorAll<VtbagIcPseudoElement>('vtbag-ic-pseudo[name="group"]')
					.forEach((i) => {
						!path(i, me) &&
							!path(me, i) &&
							i.querySelector<HTMLInputElement>('.pseudo-head .visibility input')!.click();

						function path(a: VtbagIcPseudoElement, b: VtbagIcPseudoElement) {
							let pa = a as ICPseudo;
							let pb = b as ICPseudo;
							while (pa.icParentPseudo) {
								if (pa === pb) return true;
								pa = pa.icParentPseudo as ICPseudo;
							}
							return false;
						}
					});
			});
		}

		groupChildren() {
			if (this.getAttribute('name') === 'group-children') {
				const group = this.closest<VtbagIcGroupElement>('vtbag-ic-group')!.group as Group;
				let html = '<div name="children">';

				group.children.forEach(
					(g) =>
						(html += `<button data-group="${gid(g)}" style="border: 2px solid ${color(group)}">${g.name.replace(
							/-vtbag-match-element-([0-9]+)/,
							(_, num) => `match-element<sup>(${num})</sup>`
						)}</button>`)
				);
				html += '</div>';
				this.insertAdjacentHTML('beforeend', html);
				minmax(
					this.lastElementChild as HTMLElement,
					'maximized',
					'Group names',
					sessionStorage,
					'vtbag-ic-group-children-' + this.name()
				);
			}
		}

		onIntersectionChange(entry: IntersectionObserverEntry) {
			this.classList.toggle('in-view', entry.isIntersecting);
			const group = this.closest('vtbag-ic-group');
			if (!group) return;
			const groupInView = [...group.querySelectorAll<HTMLElement>('vtbag-ic-pseudo')].some((p) =>
				p.classList.contains('in-view')
			);
			group.classList.toggle('in-view', groupInView);
			const groupId = (group.firstElementChild!.firstElementChild as HTMLElement).dataset.group;
			this.closest('vtbag-ic-scope')!
				.querySelectorAll<HTMLElement>(`button[data-group="${groupId}"]`)
				.forEach((btn) => btn.classList.toggle('in-view', groupInView));
		}
	}

	if (!customElements.get('vtbag-ic-pseudo')) customElements.define('vtbag-ic-pseudo', ICPseudo);
</script>
