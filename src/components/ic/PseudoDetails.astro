<script>
	import { ICElement } from './ic-element';
	import { setCurrentValue, slider } from './slider';
	import { setMaxValue } from './slider';
	import { printToDevtools } from './devtool-bridge';
	import { mayStartViewTransition } from '@vtbag/utensil-drawer/may-start-view-transition';
	import { createTimingBar } from './bars';
	import { shorthands } from './shorthand';
	import { gid, type Group } from './group';

	class ICPseudoDetails extends ICElement {
		pseudoName?: string;
		pseudo?: VtbagIcPseudoElement;
		formerPseudo?: VtbagIcPseudoElement;
		formerStyles?: { key: string; value: string; defaultValue: string; priority: string }[];
		formerStyleMap?: Map<string, string> = new Map();
		scope?: VtbagIcScopeElement;
		twinTO?: NodeJS.Timeout;
		tabTO?: NodeJS.Timeout;
		animations: Animation[] = [];
		maxEnd?: number;
		lastTime?: number;

		setUp() {
			this.style.display = 'none';
			addEventListener('ic-about-to-finish', () => {
				this.set('');
			});

			addEventListener('ic-time-change', async (e) => {
				const { time, element } = (e as CustomEvent).detail;

				if (!this.pseudo || (this.scope !== element && this.pseudo !== element)) return;
				setCurrentValue('details-slider', time);
				this.style.setProperty('--range-percent', `${(time / (this.maxEnd || 1)) * 100}`);
				if (origin !== 'auto-move') {
					this.animations!.forEach(
						(a) =>
							(a as Animation & { 'vtbag-stopped'?: boolean })['vtbag-stopped'] ||
							(a.currentTime = time)
					);
				}
				if (this.lastTime === time) return;
				this.lastTime = time;

				this.tabTO ||
					(this.tabTO = setTimeout(async () => {
						this.tabTO = undefined!;
						const style = await this.pseudo!.computedStyleCompact(true);
						this.updateTable(style);
						this.formerStyles = style;
					}, 0));
			});
		}

		private updateTable(
			style: { key: string; value: string; defaultValue: string; priority: string }[]
		) {
			const former: Map<string, string> = new Map();

			const lines: string[] = [];
			shorthands(
				style.filter(
					({ value, defaultValue }) => value !== defaultValue //|| this.formerStyleMap?.has(key)
				)
			)
				.sort((a, b) => a.key.localeCompare(b.key))
				.forEach(({ key, value }) => {
					lines.push(`
								<tr class="style-line">
									<td class="key">${key}:</td>
									<td class="value ${this.formerStyleMap && value !== this.formerStyleMap.get(key) ? 'changed' : ''}">${value}</td>
								</tr>`);
					former.set(key, value);
				});
			this.formerStyleMap = former;

			const table = this.querySelector<HTMLElement>('table')!;
			table.innerHTML = lines.join('');
		}

		render() {
			this.classList.add('panel');
			const open =
				sessionStorage.getItem('ic-pseudo-details-styles-open') === 'false' ? false : true;
			this.innerHTML = `
			<details open>
				<summary>Pseudo-element details</summary>
				<div class="content">
					<details class="details-styles" ${open ? 'open' : ''}>
						<summary>Computed Style</summary>
						<div class="style">
							<table>
								<tr>
									<td>Select a pseudo-element to examine its details. After you start and freeze a view transition you can select pseudo-elements form the tree view or identify them on the screen.</td>
								</tr>
							</table>
						</div>
					</div>
					</details>
				</div>
			</details>`;

			if (this.formerStyles) this.updateTable(this.formerStyles);

			this.querySelector('.details-styles')!.addEventListener('toggle', (e) => {
				const open = (e.target as HTMLDetailsElement).open;
				sessionStorage.setItem('ic-pseudo-details-styles-open', open ? 'true' : 'false');
			});
			if (!this.pseudoName) {
				//			this.style.display = 'none';
				return;
			}
			this.querySelector<HTMLElement>('summary')!.textContent = 'Details for ' + this.pseudoName;

			const content = this.querySelector('.content') as HTMLElement;

			this.showAnimations(content);

			content.lastElementChild!.insertAdjacentHTML(
				'beforebegin',
				slider('details-slider', 'detail')
			);
			this.showHideSlider();

			const time = parseInt(
				this.scope!.querySelector<HTMLInputElement>('input[name^="slider-"]')?.value ?? '0',
				10
			);
			setMaxValue('details-slider', this.maxEnd!, time, (e: Event) => {
				const time = parseInt((e.target as HTMLInputElement).value, 10);
				dispatchEvent(
					new CustomEvent('ic-time-change', {
						detail: { element: this.pseudo, origin: 'detail-slider', time },
					})
				);
			});
			dispatchEvent(
				new CustomEvent('ic-time-change', {
					detail: { element: this.pseudo, origin: 'detail-slider', time },
				})
			);
		}

		showAnimations(content: HTMLElement) {
			const clean = (animation: Animation) => {
				const hide = {
					configurable: true,
					enumerable: false,
				};
				if ('vtbag-stopped' in animation) Object.defineProperty(animation, 'vtbag-stopped', hide);
				if ('vtbag-origin' in animation) Object.defineProperty(animation, 'vtbag-origin', hide);
				if ('vtbag-alias' in animation) Object.defineProperty(animation, 'vtbag-alias', hide);
				return animation;
			};

			const updateStopMarks = (pseudo: VtbagIcPseudoElement) => {
				if (pseudo.animations().some((a) => 'vtbag-stopped' in a)) {
					pseudo!.setAttribute('data-stopped', '');
					pseudo!.twin.setAttribute('data-stopped', '');
					[...document.querySelectorAll('#identified-pseudos div')]
						.find((div) => div.textContent === pseudo.dataset.link)
						?.setAttribute('data-stopped', '');
				} else {
					pseudo!.removeAttribute('data-stopped');
					pseudo!.twin.removeAttribute('data-stopped');
					[...document.querySelectorAll('#identified-pseudos div')]
						.find((div) => div.textContent === pseudo.dataset.link)
						?.removeAttribute('data-stopped');
				}
				this.closest<VtbagIcAnimationsElement>('vtbag-ic-animations')!.querySelector<HTMLElement>(
					'.stopped-animations'
				)!.style.display = parent.document.querySelectorAll('#twins div[data-twin][data-stopped]')
					.length
					? 'grid'
					: 'none';
			};

			const short = (pseudoElement: string) =>
				pseudoElement.replace(/^::view-transition-(.*)\(([^)]*)\)$/, '$1($2)');

			const reversed = this.animations.toReversed().filter((a) => !(a as any).dead); // chrome bug workaround
			const timings = reversed.map((a) => a.effect?.getComputedTiming());
			this.maxEnd = Math.max(...reversed.map((_, idx) => timings[idx]?.endTime as number));
			let count = 0;
			content.insertAdjacentHTML(
				'afterbegin',
				'<div class="anim-container"><div class="animations"></div></div>'
			);
			const animations = content.querySelector<HTMLElement>('.animations')!;
			let lastOrigin: VtbagIcPseudoElement | undefined = undefined;
			reversed.forEach((a, idx) => {
				if ('vtbag-alias' in a && a['vtbag-alias'] === 'vtbag-ic-click-track') return;

				const name =
					short(a.effect?.pseudoElement!) +
					': ' +
					((a as CSSAnimation).animationName ??
						(('vtbag-alias' in a && a['vtbag-alias']) || 'unknown'));

				const origin =
					'vtbag-origin' in a ? (a['vtbag-origin'] as VtbagIcPseudoElement) : undefined;

				if (lastOrigin && origin !== lastOrigin)
					animations.insertAdjacentHTML('afterbegin', `<hr>`);

				lastOrigin = origin;

				animations.insertAdjacentHTML(
					'afterbegin',
					`<div style="align-items: center; display: flex; gap: 8px;">
							<label>
								<span title="delay: ${~~((timings[idx]?.delay as number) || 0)}ms, duration: ${~~((timings[idx]?.duration as number) || this.maxEnd! - ((timings[idx]?.delay as number) || 0))}ms"></span><input type="checkbox" ${'vtbag-stopped' in a ? '' : 'checked'}>${name}<span>${' vtbag-stopped' in a ? ` (stopped at ${~~a.currentTime!}ms)` : ''}</span>
							</label>
							<span style="cursor: pointer;" class="devtools" title="Show in browser console">[ðŸ–¶]</span>
						</div>`
				);
				animations
					.querySelector('span[title]')!
					.insertAdjacentElement('afterbegin', createTimingBar(timings[idx]!, this.maxEnd!));
				animations.querySelector('.devtools')!.addEventListener('click', () =>
					printToDevtools(
						'\n%s\n%o',
						name,
						Object.assign(Object.create(null), {
							animation: clean(a),
							timing: a.effect?.getComputedTiming(),
							...('transitionProperty' in a && { transitionProperty: a.transitionProperty }),
							...('animationName' in a && { keyframes: a.effect?.getKeyframes() }),
						})
					)
				);
				if ('vtbag-stopped' in a && a.playState === 'running') a.pause(); // check this

				animations.querySelector('input')!.addEventListener('change', (e) => {
					const stoppable = a as Animation & { 'vtbag-stopped'?: HTMLInputElement };
					const checkbox = e.target as HTMLInputElement;
					if (checkbox.checked) {
						delete stoppable['vtbag-stopped'];
					} else {
						stoppable['vtbag-stopped'] =
							this.scope?.querySelector<HTMLInputElement>('input[name^="slider-"]')!;
					}
					checkbox.parentElement!.lastElementChild!.innerHTML = stoppable['vtbag-stopped']
						? ` (stopped at ${~~a.currentTime!}ms)`
						: '';
					if (stoppable['vtbag-stopped']) {
						stoppable.pause(); // check this
					} else {
						const time = parseInt(
							content.querySelector<HTMLInputElement>('input[type=range]')!.value,
							10
						);
						dispatchEvent(
							new CustomEvent('ic-time-change', {
								detail: { element: this.pseudo, origin: 'detail-slider', time },
							})
						);
					}
					updateStopMarks(
						(stoppable as Animation & { 'vtbag-origin'?: VtbagIcPseudoElement })['vtbag-origin']!
					);
				});
				++count;
			});
			if (count === 0) {
				animations.insertAdjacentHTML('afterbegin', `<span class="info">No animations</span>`);
			} else {
				animations.parentElement!.insertAdjacentHTML(
					'beforeend',
					`<div id="animation-overlay"></div>`
				);
			}
		}

		set(name: string) {
			const setDetailsMark = (pseudo: VtbagIcPseudoElement, attribute: string, value: boolean) => {
				if (value) {
					pseudo!.setAttribute(attribute, '');
					pseudo!.twin.setAttribute(attribute, '');
					[...document.querySelectorAll('#identified-pseudos div')]
						.find((div) => div.textContent === pseudo.dataset.link)
						?.setAttribute(attribute, '');
				} else {
					pseudo!.removeAttribute(attribute);
					pseudo!.twin.removeAttribute(attribute);
					[...document.querySelectorAll('#identified-pseudos div')]
						.find((div) => div.textContent === pseudo.dataset.link)
						?.removeAttribute(attribute);
				}
			};

			const resetFormerAnimations = () => {
				const time = parseInt(
					this.scope!.querySelector<HTMLInputElement>('input[name^="slider-"]')?.value ?? '0',
					10
				);
				this.animations.forEach(
					(a) =>
						(a as Animation & { 'vtbag-stopped'?: boolean })['vtbag-stopped'] ||
						(a.currentTime = time)
				);
			};

			const gatherCurrentAnimations = () => {
				this.animations = [];
				const addAnimations = (pseudo: VtbagIcPseudoElement) => {
					pseudo.animations().forEach((a) => {
						(a as Animation & { 'vtbag-origin'?: VtbagIcPseudoElement })['vtbag-origin'] = pseudo;
						this.animations.push(a);
					});
					if (
						this.pseudo!.name() !== '::view-transition' &&
						pseudo.getAttribute('name') === 'group-children'
					) {
						const group = pseudo.closest<VtbagIcGroupElement>('vtbag-ic-group')!.group as Group;
						group.children.forEach((g) => {
							document
								.querySelector<VtbagIcGroupElement>(
									`vtbag-ic-group:has(h3[data-group="${gid(g)}"]`
								)!
								.querySelectorAll<VtbagIcPseudoElement>('vtbag-ic-pseudo')
								.forEach(addAnimations);
						});
					}
				};
				[this.pseudo!, ...this.pseudo!.querySelectorAll('vtbag-ic-pseudo')].forEach(addAnimations);
			};

			this.pseudo =
				[...document.querySelectorAll<VtbagIcPseudoElement>(`vtbag-ic-pseudo[data-link]`)].find(
					(p) => p.dataset.link === name
				) || undefined;

			this.formerPseudo && setDetailsMark(this.formerPseudo, 'data-current-details', false);
			this.pseudo && setDetailsMark(this.pseudo, 'data-current-details', true);

			this.pseudoName = this.pseudo ? name : undefined;
			this.scope = this.pseudo?.closest<VtbagIcScopeElement>('vtbag-ic-scope') ?? undefined;
			const details = this.querySelector<HTMLDetailsElement>('details')!;

			mayStartViewTransition(
				{
					update: () => {
						details.open = !!this.pseudoName;
						if (this.pseudoName && this.pseudo && this.scope) {
							this.style.display = 'block';
							resetFormerAnimations();
							gatherCurrentAnimations();

							this.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
							this.formerStyleMap = undefined;
							this.render();
						} else {
							this.style.display = 'none';
						}
					},
					types: ['pseudo-detail'],
				},
				{
					collisionBehavior: 'chaining',
					useTypesPolyfill: 'always',
				}
			);
			this.formerPseudo = this.pseudo;
		}

		showHideSlider() {
			const container = this.querySelector('#details-slider')?.closest(
				'.horizontal-slider-container'
			) as HTMLElement;
			const display = this.animations!.length ? 'flex' : 'none';
			container!.style.display = display;
		}
	}

	customElements.define('vtbag-ic-pseudo-details', ICPseudoDetails);
</script>

<style is:global>
	@import './styles/devtools.css';
	@import './styles/details.css';
	@layer components {
		vtbag-ic-pseudo-details {
			display: block;
			grid-column: 1 / -1;
			padding: 0.5rem 0.75rem 0.5rem 0.75rem;
			background: light-dark(#f6f6f6, #0a0a0a);
			border-radius: 4px;
			border: 1px solid light-dark(#d6d6d6, #2a2a2a);
			box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);

			.animations,
			.style {
				max-height: 50vh;
				overflow-y: auto;
			}

			.details-styles,
			.details-styles .style,
			.content .animations,
			.horizontal-slider-container {
				margin-top: 0.5rem;
			}

			.anim-container {
				position: relative;
				display: grid;
			}
			.animations {
				grid-area: 1 / 1 / 2 / 2;
				hr {
					margin: 0.2rem 1rem;
					border: none;
					border-top: 1px solid light-dark(#d6d6d6, #2a2a2a);
				}
			}

			.animations svg {
				display: inline-block;
				vertical-align: middle;
				margin: 0 0.5ch;
			}
			#animation-overlay {
				grid-area: 1 / 1 / 2 / 2;
				margin: 0 0.5ch;
				position: absolute;
				top: 8px;
				bottom: 0px;
				left: calc(var(--range-percent, 50) * 12ch / 100);
				width: calc(12ch - var(--range-percent, 50) * 12ch / 100 + 1px);
				pointer-events: none;
				background: linear-gradient(to right, light-dark(#330c, #ccfc), #0000 1px);
			}
			table {
				table-layout: fixed;
				.changed {
					color: light-dark(black, white);
				}
			}
		}
	}
</style>
