---

---
<script>
class VTBagSelect extends HTMLElement {
	_options: never[];
	_selected: number;
	_open: boolean;
	_button: HTMLButtonElement;
	_list: HTMLUListElement;
  constructor() {
    super();
    this._options = [];
    this._selected = -1;
    this._open = false;

    // UI elements (light-DOM, so styling from host document works)
    this._button = document.createElement('button');
    this._list = document.createElement('ul');

    // accessibility
    this._button.type = 'button';
    this._button.setAttribute('aria-haspopup', 'listbox');
    this._button.setAttribute('aria-expanded', 'false');
    this._list.setAttribute('role', 'listbox');
    this._list.tabIndex = -1;

    // minimal default styling (can be overridden by page CSS)
    const style = document.createElement('style');
    style.textContent = `
      :host { display: inline-block; position: relative; }
      button { width: 100%; box-sizing: border-box; }
      ul { position: absolute; left: 0; right: 0; z-index: 100000; list-style: none; margin: 4px 0 0; padding: 0; background: white; border: 1px solid #ccc; max-height: 18rem; overflow: auto; display: none; }
      li { padding: 0.4rem 0.6rem; cursor: pointer; }
      li[aria-selected="true"] { background: Highlight; color: HighlightText; }
      li:focus { outline: none; background: rgba(0,0,0,0.06); }
    `;

    this.appendChild(style);
    this.appendChild(this._button);
    this.appendChild(this._list);

    // handlers bound
    this._onDocClick = this._onDocClick.bind(this);
    this._onButtonClick = this._onButtonClick.bind(this);
    this._onKeyDown = this._onKeyDown.bind(this);
  }

  connectedCallback() {
    this._upgradeProperty('value');
    this._parseOptionsFromChildren();
    this._render();

    this._button.addEventListener('click', this._onButtonClick);
    this.addEventListener('keydown', this._onKeyDown);
    document.addEventListener('click', this._onDocClick);

    if (!this.hasAttribute('tabindex')) this.setAttribute('tabindex', '0');
  }

  disconnectedCallback() {
    this._button.removeEventListener('click', this._onButtonClick);
    this.removeEventListener('keydown', this._onKeyDown);
    document.removeEventListener('click', this._onDocClick);
  }

  // preserve pre-upgrade property values
  _upgradeProperty(prop) {
    if (Object.prototype.hasOwnProperty.call(this, prop)) {
      const value = this[prop];
      delete this[prop];
      this[prop] = value;
    }
  }

  // read <option> children (light DOM) and remove them from DOM; accepts <option> or elements with data-value
  _parseOptionsFromChildren() {
    const childOptions = Array.from(this.querySelectorAll('option, [data-value]'));
    if (childOptions.length === 0) return;

    this._options = childOptions.map(opt => {
      const value = opt.tagName.toLowerCase() === 'option' ? opt.value : opt.getAttribute('data-value');
      const label = (opt.textContent || '').trim();
      return { value: String(value ?? ''), label: label || String(value ?? '') };
    });

    // remove original children so we control rendering
    childOptions.forEach(n => n.remove());

    // keep selected if an option had selected attribute
    const preSel = childOptions.findIndex(opt => opt.hasAttribute && opt.hasAttribute('selected'));
    if (preSel >= 0) this._selected = preSel;
  }

  _render() {
    // button text
    const label = this._selected >= 0 && this._options[this._selected]
      ? this._options[this._selected].label
      : this.getAttribute('placeholder') || '';

    this._button.textContent = label;

    // list
    this._list.innerHTML = '';
    this._options.forEach((opt, i) => {
      const li = document.createElement('li');
      li.setAttribute('role', 'option');
      li.tabIndex = -1;
      li.dataset.index = String(i);
      li.textContent = opt.label;
      li.setAttribute('aria-selected', String(this._selected === i));
      li.addEventListener('click', () => this._selectIndex(i));
      li.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this._selectIndex(i); }
      });
      this._list.appendChild(li);
    });

    this._updateListVisibility();
  }

  _updateListVisibility() {
    if (this._open) {
      this._list.style.display = '';
      this._button.setAttribute('aria-expanded', 'true');
    } else {
      this._list.style.display = 'none';
      this._button.setAttribute('aria-expanded', 'false');
    }
  }

  _onButtonClick(e) {
    e.stopPropagation();
    this.toggle();
  }

  _onDocClick(e) {
    if (!this.contains(e.target)) this.close();
  }

  _onKeyDown(e) {
    // keyboard on host: open/close and navigate
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (!this._open) { this.open(); this._focusOption(0); }
      else this._focusNext();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (!this._open) { this.open(); this._focusOption(this._options.length - 1); }
      else this._focusPrev();
    } else if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      if (!this._open) this.open();
      else {
        const focused = this._list.querySelector('li:focus');
        const idx = focused ? Number(focused.dataset.index) : this._selected;
        if (idx >= 0) this._selectIndex(idx);
      }
    } else if (e.key === 'Escape') {
      if (this._open) { e.preventDefault(); this.close(); this._button.focus(); }
    }
  }

  _focusOption(i) {
    const li = this._list.querySelector(`li[data-index="${i}"]`);
    if (li) li.focus();
  }
  _focusNext() {
    const focused = this._list.querySelector('li:focus');
    const idx = focused ? Number(focused.dataset.index) : -1;
    const next = Math.min(this._options.length - 1, idx + 1);
    this._focusOption(next);
  }
  _focusPrev() {
    const focused = this._list.querySelector('li:focus');
    const idx = focused ? Number(focused.dataset.index) : this._options.length;
    const prev = Math.max(0, idx - 1);
    this._focusOption(prev);
  }

  _selectIndex(i) {
    const prev = this._selected;
    this._selected = i;
    this._render();
    this.close();
    this._button.focus();

    const value = this._options[i]?.value ?? '';
    // reflect attribute
    this.setAttribute('value', value);
    // dispatch input/change events
    if (prev !== i) {
      this.dispatchEvent(new Event('input', { bubbles: true }));
      this.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  open() {
    if (this._options.length === 0) return;
    this._open = true;
    this._updateListVisibility();
    // focus selected option
    this._focusOption(this._selected >= 0 ? this._selected : 0);
  }

  close() {
    this._open = false;
    this._updateListVisibility();
  }

  toggle() {
    this._open ? this.close() : this.open();
  }

  // properties
  get value() {
    return this._options[this._selected]?.value ?? '';
  }
  set value(v) {
    const idx = this._options.findIndex(o => o.value === String(v));
    if (idx >= 0) this._selectIndex(idx);
    else {
      this._selected = -1;
      this.removeAttribute('value');
      this._render();
    }
  }

  // reflect value attribute to property
  static get observedAttributes() { return ['value']; }
  attributeChangedCallback(name, oldVal, newVal) {
    if (name === 'value' && oldVal !== newVal) this.value = newVal;
  }
}

if (!customElements.get('vtbag-ic-select')) customElements.define('vtbag-ic-select', VTBagSelect);
</script>