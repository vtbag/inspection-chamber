<script>
	import type { Group } from './group';
	import { key } from './scope.ts';
	import { mayStartViewTransition } from '@vtbag/utensil-drawer/may-start-view-transition';

	class ICPseudo extends HTMLElement {
		#computedStyle: CSSStyleDeclaration | undefined;
		#dirty = false;
		#animations: Animation[] = [];

		constructor() {
			super();
		}

		set animations(value: Animation[]) {
			if (value.some((a) => !this.#animations.includes(a))) {
				this.#animations = [...new Set<Animation>([...this.#animations, ...value])];

				this.#dirty = true;
				this.render();
			}
		}
		connectedCallback() {
			this.render();
		}

		static get observedAttributes() {
			return ['name'];
		}

		get exists() {
			return this.#computedStyle?.width !== 'auto';
		}

		attributeChangedCallback(name: string, oldValue: string, newValue: string) {
			if (oldValue !== newValue) {
				this.#dirty = true;
				this.render();
			}
		}

		render() {
			if (this.isConnected && this.#dirty) {
				this.#dirty = false;

				let scope;
				let groupElement;
				let name = this.getAttribute('name');
				if (name === '::view-transition') {
					scope = (this.closest('vtbag-ic-scope') as VtbagIcScopeElement).element;
				} else {
					groupElement = this.closest('vtbag-ic-group') as VtbagIcGroupElement;
					name = `::view-transition-${name}(${groupElement.name})`;
					scope = groupElement.scope.element;
				}
				// todo: simplify
				this.#computedStyle = scope?.ownerDocument.defaultView?.getComputedStyle(scope, name);

				// potentially "slotted" elements

				const hidden = scope.ownerDocument.head.querySelector(`#vtbag-vis-${CSS.escape(name)}`);
				this.insertAdjacentHTML(
					'afterbegin',
					`<span class="pseudo-head"><span class="name">${this.getAttribute('name')?.replace('image-pair', 'pair').replace('group-children', 'children') || '::view-transition'}</span>
					<button class="toggle frame">ðŸ–½</button>
					<label class="toggle visibility">
	<input type="checkbox" style="position: absolute; opacity: 0; pointer-events: none;" ${hidden ? '' : 'checked'}>
	<svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	<use href="#icon-eye-on"/></svg></label>
	${
		this.getAttribute('name') === 'group'
			? `<label class="toggle solo"><input type="checkbox" style="position: absolute; opacity: 0; pointer-events: none;">s
		</label>`
			: ''
	}</span>
  `
				);
				hidden && ((this.children[1] as HTMLDivElement).style.display = 'none');

				visibility(this, scope, name);
				solo(this);
				groupChildren(this, scope, groupElement!);
			}
		}
	}

	if (!customElements.get('vtbag-ic-pseudo')) customElements.define('vtbag-ic-pseudo', ICPseudo);

	function visibility(pseudo: ICPseudo, scope: HTMLElement, name: string) {
		pseudo.querySelector<HTMLInputElement>('.visibility input')!.addEventListener('click', (e) => {
			const checkbox = e.target as HTMLInputElement;
			const use = checkbox.nextElementSibling!.querySelector('use')!;
			const checked = checkbox.checked;
			use.href.baseVal = checked ? '#icon-eye-on' : '#icon-eye-off';
			scope.ownerDocument.head.querySelector(`#vtbag-vis-${CSS.escape(name)}`)?.remove();
			if (!checked) {
				scope.ownerDocument.head.insertAdjacentHTML(
					'beforeend',
					`<style id="vtbag-vis-${name}">${name} { opacity: 0}</style>`
				);
			}
			const inner = checkbox.closest('vtbag-ic-pseudo')?.children[1] as HTMLDivElement;
			inner &&
				mayStartViewTransition(
					{
						update: () => {
							inner.style.display = checked ? '' : 'none';
						},
						types: ['visibility-toggle'],
					},
					{ collisionBehavior: 'chaining', useTypesPolyfill: 'always' }
				);
		});
	}

	function solo(pseudo: ICPseudo) {
		pseudo.querySelector<HTMLInputElement>('.solo input')?.addEventListener('click', (e) => {
			if ((e.target as HTMLElement).tagName !== 'INPUT') return;
			const checkbox = e.target as HTMLInputElement;

			document
				.querySelectorAll<HTMLInputElement>('.visibility input:not(:checked)')
				.forEach((h) => h.click());

			const solos = document.querySelectorAll<HTMLInputElement>(
				`vtbag-ic-pseudo .solo input:checked`
			);

			if (solos.length === 0) return;

			solos.forEach((v) => v !== checkbox && ((v.checked = false), v.removeAttribute('checked')));

			const me = checkbox.closest('vtbag-ic-pseudo');
			document
				.querySelectorAll<VtbagIcPseudoElement>('vtbag-ic-pseudo[name="group"]')
				.forEach(
					(i) =>
						i !== me && i.querySelector<HTMLInputElement>('.pseudo-head .visibility input')!.click()
				);
		});
	}

	function groupChildren(pseudo: ICPseudo, scope: HTMLElement, groupElement: VtbagIcGroupElement) {
		if (pseudo.getAttribute('name') === 'group-children') {
			const group = pseudo
				.closest<VtbagIcAnimationsElement>('vtbag-ic-animations')!
				.groupMaps.get(key(scope))
				?.get(groupElement!.name) as Group;
			let html = '<div name="children">';
			let root = group;
			while (root.parent) root = root.parent;
			group.children.forEach(
				(g) =>
					(html += `<button data-group="${g.preOrder}" style="border: 2px solid oklch(0.7 0.07 ${(360 / (root.postOrder! - root.preOrder! + 1)) * g.preOrder!}deg / 1)">${g.name.replace(
						/-vtbag-match-element-([0-9]+)/,
						(_, num) => `match-element<sup>(${num})</sup>`
					)}</button>`)
			);
			html += '</div>';
			pseudo.insertAdjacentHTML('beforeend', html);
		}
	}
</script>
