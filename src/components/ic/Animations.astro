---
import PseudoDetails from './PseudoDetails.astro';
import Scope from './Scope.astro';
import './ic.css';
import './studio.css';
---

<Scope />
<PseudoDetails />
<template id="vtbag-ic-animations">
	<div class="animations-head" style="--vtn: animations-head">
		<div class="animations-head-main" style="--vtn: animations-head-main; display:none">
			<span>View Transitions: <span id="view-transitions">0</span></span>
			<span id="scopes">Scopes:</span>
			<span id="scope-buttons"></span>
		</div>
	</div>
	<div class="scope-container" style="--vtn: scope-container"></div>
</template>
<script>
	import { addBlinds } from './blinds';
	import { moduleGroupMaps } from './capture';
	import { type Group } from './group';
	import { highlight } from './highlight';
	import { disableLedGroup, enableLedGroup, hideLedGroup, ledGroup } from './led-group';
	import { mayStartViewTransition } from '@vtbag/utensil-drawer/may-start-view-transition';

	class ICAnimations extends HTMLElement {
		#initialized = false;
		groupMaps: Map<Element, Map<string, Group>>;
		#scopes = new Map<HTMLElement, VtbagIcScopeElement>();
		#observer?: ResizeObserver;
		#rootDocument?: Document;
		#pseudosToMove: VtbagIcPseudoElement[] = [];
		#retriggerPseudosToMove: boolean = false;

		constructor() {
			super();
			this.groupMaps = moduleGroupMaps;
			self.addEventListener('ic-about-to-finish', (e) => {
				mayStartViewTransition(
					{
						update: () => {
							const root = (e as CustomEvent).detail.root;
							const scope = this.#scopes.get(root)!;
							this.#scopes.delete(root);
							scope?.remove();
							!this.#scopes
								.keys()
								.some((rootElement) => rootElement.ownerDocument.documentElement === rootElement) &&
								parent.document.documentElement.classList.remove('action');
							this.renderHead();
							this.updateAnimationsHead();
							if (this.#scopes.size === 0) {
								this.querySelector<VtbagIcIdentifyElement>('vtbag-ic-identify')?.hide();
								this.querySelector<HTMLInputElement>('#reset-stopped-animations')?.click();
							}
						},
						types: ['vt-exit'],
					},
					{ collisionBehavior: 'chaining', useTypesPolyfill: 'always' }
				);
			});
		}

		disconnectedCallback() {
			console.log('ICAnimations disconnected');
			this.#observer?.disconnect();
			this.querySelectorAll<VtbagIcScopeElement>('vtbag-ic-scope').forEach((s) =>
				s.element.activeViewTransition?.skipTransition()
			);
			this.querySelector<VtbagIcScopeElement>(
				'vtbag-ic-scope'
			)?.element.ownerDocument.activeViewTransition?.skipTransition();
			removeEventListener('ic-after-capture-new', this.mayRender);
		}

		connectedCallback() {
			this.#observer = new ResizeObserver(([entry]) => {
				const { inlineSize: w, blockSize: h } = entry.contentBoxSize[0] ?? entry.contentRect;
				const orientation = w > h ? 'landscape' : 'portrait';
				if (orientation !== document.documentElement.dataset.orientation) {
					document.documentElement.dataset.orientation = orientation;
				}
			});
			this.#observer.observe(this.parentElement!);

			if (this.#initialized) return;
			this.#initialized = true;

			this.appendChild(
				(document.getElementById('vtbag-ic-animations') as HTMLTemplateElement).content.cloneNode(
					true
				)
			);
			this.querySelector<HTMLSpanElement>('#scopes')!.style.display = 'none';
			const animationHead = this.querySelector<HTMLDivElement>('div.animations-head')!;
			animationHead.insertAdjacentHTML(
				'afterbegin',
				ledGroup({
					independent: true,
					className: 'stopped-animations',
					groupName: 'stopped-animations',
					checked: 'reset',
					alternatives: [
						{
							label: 'Reset all stopped animations',
							value: 'reset',
							id: 'reset-stopped-animations',
						},
					],
				})
			);
			(animationHead.firstElementChild as HTMLDivElement).style.gridColumn = 'span 2';
			const reset =
				animationHead.firstElementChild!.querySelector<HTMLInputElement>('input[type=checkbox]')!;
			reset.classList.add('red');
			reset.addEventListener('click', () => {
				const run = this.querySelector('#run:checked');
				reset.checked = true;
				this.#rootDocument!.getAnimations().forEach((a) => {
					if ('stopped' in a) {
						a.currentTime = parseInt((a.stopped as HTMLInputElement).value, 10);
						delete a.stopped;
						run && a.play();
					}
				});
				parent.document
					.querySelectorAll<HTMLElement>('#twins div[data-stopped]')
					.forEach((div) => div.removeAttribute('data-stopped'));
				this.querySelectorAll<HTMLElement>('vtbag-ic-identify div[data-stopped]').forEach((div) =>
					div.removeAttribute('data-stopped')
				);
				this.querySelectorAll<HTMLElement>(`vtbag-ic-pseudo[data-stopped]`).forEach((pseudo) =>
					pseudo.removeAttribute('data-stopped')
				);
				const detail = this.querySelector<VtbagIcPseudoDetailsElement>('vtbag-ic-pseudo-details');
				const minimized = detail?.querySelector<HTMLInputElement>('.minmax input')!;
				if (!minimized.checked) {
					const pseudo = detail?.querySelector('h3')?.textContent;
					pseudo && detail?.set(pseudo);
				}
				this.querySelector<HTMLElement>('.stopped-animations')!.style.display = 'none';
			});
			hideLedGroup(this.querySelector<HTMLDivElement>('.input-led-group.stopped-animations')!);

			animationHead.insertAdjacentHTML(
				'beforeend',
				ledGroup({
					className: 'freeze',
					groupName: 'freeze',
					checked: 'freeze',
					alternatives: [
						{
							label: 'Freeze',
							value: 'freeze',
							id: 'freeze',
						},
						{
							label: 'Next',
							value: 'next',
							id: 'next',
						},
						{
							label: 'Run',
							value: 'run',
							id: 'run',
						},
					],
				})
			);

			animationHead.insertAdjacentHTML(
				'beforeend',
				ledGroup({
					className: 'slow-mo',
					groupName: 'slow-mo',
					checked: 'normal',
					alternatives: [
						{
							label: 'Normal',
							value: 'normal',
							id: 'normal',
						},
						{
							label: 'Slow',
							value: 'slow',
							id: 'slow',
						},
						{
							label: 'Slower',
							value: 'slower',
							id: 'slower',
						},
					],
				})
			);
			disableLedGroup(
				this.querySelector<HTMLDivElement>('.input-led-group.slow-mo')!,
				'To enable speed control, select Run mode.'
			);

			animationHead.insertAdjacentHTML(
				'beforeend',
				'<vtbag-ic-pseudo-details></vtbag-ic-pseudo-details>'
			);
			animationHead.insertAdjacentHTML('beforeend', '<vtbag-ic-identify></vtbag-ic-identify>');

			this.querySelector('.freeze')!.addEventListener('click', (e) => {
				this.#pseudosToMove.length = 0;
				const clicked = e.target as HTMLInputElement;
				if (clicked.tagName !== 'INPUT') return;

				const freeze = () => {
					this.updateAnimationsHead();
					const freezeOption = this.querySelector<HTMLInputElement>(
						'input[name="freeze"]:checked'
					)?.value;
					if (freezeOption) {
						if (this.#scopes.size === 0) {
							if (freezeOption === 'freeze') {
								this.refreshAnimations(this.#rootDocument?.getAnimations() ?? [])!;
								return;
							}
							if (freezeOption === 'next') {
								this.#rootDocument?.getAnimations().forEach((a) => {
									a.finish();
								});
								return;
							}
						}
						this.querySelectorAll<HTMLInputElement>(
							`.scope-container input[value=${freezeOption}]`
						).forEach((input) => {
							input.click();
						});
					}
				};
				mayStartViewTransition(
					{ update: freeze, types: ['freeze'] },
					{
						collisionBehavior: true || this.#scopes.size ? 'never' : 'chaining',
						useTypesPolyfill: 'always',
					}
				);
			});

			this.querySelector('.slow-mo')!.addEventListener('click', (e) => {
				if ((e.target as HTMLElement).tagName !== 'INPUT') return;

				const slowMo = () => {
					const speed = (e.target as HTMLInputElement).value;

					if (this.#scopes.size === 0) {
						this.#rootDocument?.getAnimations().forEach((a) => {
							a.updatePlaybackRate(speed === 'normal' ? 1 : speed === 'slow' ? 0.1 : 0.01);
						});
					} else {
						this.querySelectorAll<VtbagIcScopeElement>('vtbag-ic-scope').forEach((scope) => {
							scope.animations.forEach((a) => {
								a.updatePlaybackRate(speed === 'normal' ? 1 : speed === 'slow' ? 0.1 : 0.01);
							});
						});
					}
					this.updateAnimationsHead();
				};
				mayStartViewTransition(
					{ update: slowMo, types: ['slow-mo'] },
					{ collisionBehavior: 'never', useTypesPolyfill: 'always' }
				);
			});

			addEventListener('ic-after-capture-new', this.mayRender);
			// track animations that are created late during the transition
			//	addEventListener('ic-animation-start', this.mayRender);

			this.querySelector<HTMLSelectElement>('#scope-buttons')!.addEventListener('click', (e) => {
				const button = e.target as HTMLButtonElement;
				if (button.tagName === 'BUTTON') {
					const scope = [...this.#scopes.values()].find((s) => s.path === button.value);
					highlight(scope);
				}
			});
			setTimeout(() => this.updateAnimationsHead(), 100);
		}

		mayRender = (e: Event) => {
			const detail = (e as CustomEvent).detail;
			const transitionRoot: HTMLElement = detail.root;
			this.#rootDocument = transitionRoot.ownerDocument;

			if (transitionRoot === this.#rootDocument.documentElement)
				parent.document.documentElement.classList.add('action');

			let update = () => {};

			if (this.querySelector<HTMLInputElement>('#run')?.checked) {
				const speed = this.querySelector<HTMLInputElement>('input[name="slow-mo"]:checked')?.value;
				if (speed !== 'normal') {
					this.#rootDocument!.getAnimations().forEach((a) => {
						a.updatePlaybackRate(speed === 'slow' ? 0.1 : 0.01);
					});
				}
				return;
			} else {
				this.#rootDocument?.getAnimations().forEach((a) => a.pause());
				queueMicrotask(() => this.#rootDocument?.getAnimations().forEach((a) => a.pause()));
				update = () => {
					this.querySelector<VtbagIcIdentifyElement>('vtbag-ic-identify')?.show();
					this.querySelector<HTMLDivElement>('.animations-head-main')!.style.display = '';
					this.refreshAnimations(this.#rootDocument!.getAnimations())!;
					this.renderHead();
				};
			}
			mayStartViewTransition(
				{ update, types: ['vt-entry'] },
				{ collisionBehavior: 'chaining', useTypesPolyfill: 'always' }
			);
		};

		private renderHead() {
			const firstScopeFreeze = this.querySelector<HTMLElement>('.scope-container .freeze');
			const newDisplay = this.#scopes.size <= 1 ? 'none' : 'flex';
			if (firstScopeFreeze && firstScopeFreeze.style.display !== newDisplay) {
				firstScopeFreeze.style.display = newDisplay;
			}
			firstScopeFreeze?.closest('vtbag-ic-scope')!.updateScopeHead();

			const scopeContainer = this.querySelector<HTMLDivElement>('div.scope-container')!;
			this.querySelector<HTMLSpanElement>('#view-transitions')!.innerText = '' + this.#scopes.size;
			this.querySelector<HTMLSpanElement>('#scopes')!.style.display =
				this.#scopes.size > 1 ? 'inline' : 'none';

			const buttons = this.querySelector('#scope-buttons')!;
			buttons.innerHTML = '';
			[...this.#scopes.values().map((s) => s.path)]
				.sort((a, b) => a.localeCompare(b))
				.forEach((path) => {
					buttons.insertAdjacentHTML('beforeend', `<button value="${path}">${path}</button>`);
				});

			const sorted = [...scopeContainer.children].sort((a, b) =>
				a.querySelector('span')!.innerText.localeCompare(b.querySelector('span')!.innerText)
			);

			if ('moveBefore' in Element.prototype)
				// @ts-ignore
				sorted.forEach((s) => scopeContainer.moveBefore(s, null));
			else sorted.forEach((s) => scopeContainer.appendChild(s));
		}

		refreshAnimations(animations: Animation[], render = true) {
			const newScopes = new Map<HTMLElement, Animation[]>();
			let count = 0;
			animations.forEach((a) => {
				if (
					a.effect?.pseudoElement?.startsWith('::view-transition') &&
					// todo: deal with other types of animation
					a.effect?.target
				) {
					if (a.constructor.name !== 'CSSAnimation') {
						const aliased: Animation & { alias?: string } = a;
						if (a.constructor.name === 'Animation') {
							aliased.alias = `WAAPI animation (${properties(a)})`;
						} else if (a.constructor.name === 'CSSTransition') {
							aliased.alias = `CSS Transition (${(a as CSSTransition).transitionProperty})`;
						} else {
							aliased.alias = `Unknown animation type: ${a.constructor.name} (${count++})`;
						}
					}

					const scope = a.effect!.target!;
					let animations = newScopes.get(scope);
					if (!animations) {
						animations = [];
						newScopes.set(scope, animations);
					}
					animations.push(a);

					function properties(a: Animation) {
						return [
							...new Set(
								a.effect
									?.getKeyframes()
									.flatMap(({ offset, computedOffset, easing, composite, ...props }) =>
										Object.keys(props)
									)
							),
						].join(', ');
					}
				}
			});
			render &&
				newScopes.forEach((animations, element) => {
					let scope = this.#scopes.get(element)!;
					if (!scope) {
						scope = document.createElement('vtbag-ic-scope');
						scope.init(element, this.groupMaps.get(element)!.get('@')!, animations);
						this.#scopes.set(element, scope);
						this.querySelector<HTMLDivElement>('div.scope-container')!.appendChild(scope);
					}
					if (
						scope.animations?.length !== animations.length ||
						scope.animations.some((a, i) => a !== animations[i])
					) {
						scope.animations = animations;
					}
				});
			return newScopes;
		}

		updateAnimationsHead() {
			this.querySelector<HTMLDivElement>('.animations-head-main')!.style.display =
				this.#scopes.size > 0 ? '' : 'none';

			const slowMo = this.querySelector<HTMLDivElement>('.input-led-group.slow-mo')!;
			if (this.#scopes.size > 0 || this.querySelector('.freeze input[value="run"]:checked'))
				enableLedGroup(slowMo);
			else disableLedGroup(slowMo, 'To enable the speed control, select Run mode.');

			const color = { red: this.#scopes.size > 0, green: this.#scopes.size === 0 };

			this.#scopes.forEach(
				(scope) =>
					(color[
						scope.querySelector<HTMLInputElement>(`input[value^="run"]`)?.checked ? 'red' : 'green'
					] = false)
			);
			this.querySelectorAll('.animations-head input[name=freeze]').forEach((e) =>
				e.classList.remove('red', 'orange')
			);
			if (color.red)
				this.querySelector('.animations-head input[name=freeze]:checked')!.classList.add('red');
			if (color.red === color.green) {
				this.querySelector('.animations-head input[name=freeze]:checked')!.classList.add('orange');
			}
			addBlinds(
				this.querySelector('.animations-head')!,
				'div',
				'head-blind',
				'animations-head',
				'blind'
			);
		}

		movePseudos() {
			const movePseudosCallback = () => {
				const twins = parent.document.documentElement.classList.contains('show-twins');

				if (true || twins) {
					if (this.#retriggerPseudosToMove && this.#pseudosToMove.length === 0) {
						this.querySelectorAll('vtbag-ic-pseudo').forEach((p) => this.#pseudosToMove.push(p));
						this.#retriggerPseudosToMove = false;
					}
					if (this.#pseudosToMove.length) {
						for (let i = 0; i < 5; ++i) this.#pseudosToMove.shift()?.moveTwin();
						setTimeout(movePseudosCallback);
					}
				} else {
					//	this.#pseudosToMove.length = 0;
				}
			};
			this.#retriggerPseudosToMove = true;
			if (this.#pseudosToMove.length === 0) movePseudosCallback();
		}
	}

	if (!customElements.get('vtbag-ic-animations'))
		customElements.define('vtbag-ic-animations', ICAnimations);


	self.addEventListener('ic-before-capture-new', (e) => {
		const head = (e as CustomEvent).detail.root.ownerDocument.head;
		head.querySelector('#vtbag-ic-persistent-style') ||
			head.insertAdjacentHTML(
				'beforeend',
				`
<style id="vtbag-ic-persistent-style">
	::view-transition-image-pair(*),
	::view-transition-old(*),
	::view-transition-new(*) {
	--vtbag-ic-only-child: initial;
}
::view-transition-image-pair(*):only-child,
::view-transition-old(*):only-child,
::view-transition-new(*):only-child {
	--vtbag-ic-only-child: "1";
}
</style>
`
			);
	});
</script>
