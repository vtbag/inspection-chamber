import { namedElements, allRoots } from '@/css';
import { deriveCSSSelector } from './element-selector';
import { gid, nestGroups, numberGroupsDFS, type Group } from './group';
import { addParentLinks, print, sort, type SparseDOMNode } from './sparse-dom';
import { message } from './message';

let idCount = 0;

export const moduleGroupMaps = new Map<Element, Map<string, Group>>();

function capture(
	transitionRoot: HTMLElement,
	groups: Map<string, Group>,
	oldOrNew: 'old' | 'new'
): string {
	let sheet = '';
	const seen = new Set<string>();
	const elementMap = new Map<Element, SparseDOMNode>();
	const sparseDOM: SparseDOMNode[] = [];

	allRoots.add(transitionRoot);
	const { elements: named } = namedElements(transitionRoot);

	const style = getComputedStyle(transitionRoot);
	let rootNode: SparseDOMNode = {
		viewTransitionName: 'none',
		element: transitionRoot,
		style,
		children: [],
	};
	elementMap.set(transitionRoot, rootNode);

	named.forEach(({ element, pseudoElement }) => {
		const path = deriveCSSSelector(element);
		const key = path + (pseudoElement ? pseudoElement : '');
		if (seen.has(key)) return;
		seen.add(key);

		let style: CSSStyleDeclaration;
		try {
			style = element.ownerDocument.defaultView!.getComputedStyle(element, pseudoElement);
		} catch (e) {
			console.error(e);
			return;
		}

		if (style.viewTransitionName === 'none' && style.viewTransitionScope === 'none') return;
		if (style.viewTransitionName !== 'none') {
			if (style.display === 'none' || style.display === 'contents') return;
			if (style.visibility === 'hidden') return;
			if (element.getClientRects().length === 0) return;
		}
		const potentiallyRenamed = renameAutoGeneratedNames();
		const node = {
			element,
			pseudoElement,
			viewTransitionName: potentiallyRenamed,
			viewTransitionGroup: style.viewTransitionGroup,
			viewTransitionClass: style.viewTransitionClass,
			viewTransitionScope: style.viewTransitionScope,
			style,
			children: [],
		};
		sparseDOM.push(node);
		if (!pseudoElement) elementMap.set(element, node);

		function cssUnescape(str: string): string {
			return str
				?.replace(/\\([0-9a-fA-F]{1,6})\s?/g, (_match, hex) =>
					String.fromCharCode(parseInt(hex, 16))
				)
				?.replace(/\\(.)/g, '$1');
		}
		function renameAutoGeneratedNames() {
			const name = cssUnescape(style.viewTransitionName);
			if (name === 'match-element' || (name === 'auto' && !element.id)) {
				const idKey = `vtbag-auto-name-id${pseudoElement ? pseudoElement : ''}`;
				let id = (element as any)[idKey] as string | undefined;
				if (!id) {
					(element as any)[idKey] = id = `-vtbag-${name}-${++idCount}`;
				}
				sheet += `${key} { view-transition-name: ${CSS.escape(id)} !important}\n`;
				return id;
			}
			return name;
		}
	});

	rootNode = elementMap.get(transitionRoot)!;
	rootNode.paintGroup = rootNode.zIndex = 0;

	addParentLinks(sparseDOM, elementMap, transitionRoot);
	sort(rootNode);

	const groupRoot = groups.get('@')!;
	groupRoot[oldOrNew] = rootNode;
	const capture = !!document.querySelector<HTMLInputElement>('#capture')?.checked;

	if (nestGroups(rootNode, groupRoot, groupRoot, groups, oldOrNew, capture, false)) {
		message(
			'error',
			`<b>Duplicate</b> view transition <b>names</b> detected <b>during capture of ${oldOrNew} images</b>. ` +
				(capture
					? `Check capture results below for details.`
					: `Enable <b>Analyze capturing</b> mode below to see details.`)
		);
	}

	numberGroupsDFS(groupRoot);
	return sheet;
}

['ic-before-capture-old', 'ic-before-capture-new'].forEach((eventName) =>
	self.addEventListener(eventName, (event) => {
		const detail = (event as CustomEvent).detail;
		const transitionRoot = detail.root;
		const crossDocument = detail.features.crossDocument;
		let groups;
		let sheet;

		if (eventName === 'ic-before-capture-old') {
			groups = new Map<string, Group>([
				['@', { name: '' + moduleGroupMaps.size, className: '', children: [], ancestor: false }],
			]);
			moduleGroupMaps.set(transitionRoot, groups);
			sheet = capture(transitionRoot, groups, 'old');
			if (crossDocument) {
				moduleGroupMaps.set(undefined!, groups);
				parent.__vtbag.ic2!.crossDocumentGroups = groups;
			}
		} else {
			if (crossDocument) {
				moduleGroupMaps.set(undefined!, parent.__vtbag.ic2!.crossDocumentGroups!);
				moduleGroupMaps.set(transitionRoot, moduleGroupMaps.get(undefined!)!);
			}
			groups = moduleGroupMaps.get(transitionRoot)!;
			sheet = capture(transitionRoot, groups, 'new');
		}

		const head = transitionRoot.ownerDocument.head;
		head.insertAdjacentHTML(
			'beforeend',
			`<style id="vtbag-ic-temp-style-${gid(groups.get('@'))}">${sheet}</style>`
		);
	})
);

['ic-after-capture-old', 'ic-after-capture-new', 'ic-ready-error'].forEach((eventName) =>
	self.addEventListener(eventName, (event) => {
		const detail = (event as CustomEvent).detail;
		const root = detail.root;
		root.ownerDocument.head
			.querySelector(`#vtbag-ic-temp-style-${gid(moduleGroupMaps.get(root)?.get('@'))}`)
			?.remove();
	})
);

self.addEventListener('ic-about-to-finish', (e) => {
	const transitionRoot = (e as CustomEvent).detail.root;
	moduleGroupMaps.delete(transitionRoot);
	allRoots.delete(transitionRoot);
	parent.__vtbag.ic2!.vtMap!.delete(transitionRoot);
	transitionRoot.ownerDocument.documentElement === transitionRoot &&
		parent.__vtbag.ic2!.vtMap!.delete(undefined!);
});
