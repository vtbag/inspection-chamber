---
import Group from './Group.astro';
---

<Group />
<script>
	import type { Group } from './group';
	import { key } from './scope';

	class ICGroupList extends HTMLElement {
		#initialized = false;
		#animations: Animation[] = [];
		#dirty = false;
		#observer?: ResizeObserver;
		cards: Map<string, VtbagIcGroupElement>;

		constructor() {
			super();
			this.cards = new Map();
		}
		connectedCallback() {
			if (!this.#initialized) {
				this.#initialized = true;
			}
			this.#observer = new ResizeObserver(() => {
				this.layout();
			});
			this.layout();
			this.render();
		}
		private layout() {
			/*
			const gap = parseFloat(getComputedStyle(this).columnGap);
			([...this.children] as HTMLElement[]).forEach((child) => {
				child.style.gridRowEnd = `span ${Math.round(child.getBoundingClientRect().height + gap)}`;
			});
			*/
		}

		disconnectCallback() {
			this.#observer?.disconnect();
		}

		get animations() {
			return this.#animations;
		}

		set animations(value: Animation[]) {
			this.#animations = value;
			this.#dirty = true;
			this.render();
		}

		async render() {
			if (this.isConnected && this.#dirty) {
				this.#dirty = false;

				const scope = this.closest<VtbagIcScopeElement>('vtbag-ic-scope');
				const groups = this.closest<VtbagIcAnimationsElement>('vtbag-ic-animations')!.groupMaps.get(
					key(scope!.element)
				)!;

				const newGroups = new Map<string, Animation[]>();
				this.#animations.forEach((anim) => {
					const groupName = (anim.effect as any as KeyframeEffect).pseudoElement?.replace(
						/::view-transition.*\((.*)\)/,
						'$1'
					);
					if (groupName) {
						let groupAnimations = newGroups.get(groupName);
						if (!groupAnimations) {
							groupAnimations = [];
							newGroups.set(groupName, groupAnimations);
						}
						groupAnimations.push(anim);
					}
				});

				newGroups.forEach((group, name) => {
					this.refreshGroup(name, group, groups.get(name)!);
				});
				this.cards.forEach((group, name) => {
					if (!newGroups.has(name)) {
						group.remove();
						this.cards.delete(name);
					}
				});

				this.sort(
					scope!.querySelector<HTMLInputElement>('input[value="alpha"]')?.checked ? 'alpha' : 'paint-order'
				);
			}
		}

		sort(by: 'alpha' | 'paint-order') {
			[...this.children]
				.sort((a, b) => {
					const ag = a as VtbagIcGroupElement;
					const bg = b as VtbagIcGroupElement;
					return by === 'paint-order'
						? ag.group.preOrder - bg.group.preOrder
						: ag.name.replace(/^-vtbag-/, '').localeCompare(bg.name.replace(/^-vtbag-/, ''));
				})

				.forEach((c) => this.appendChild(c));
		}

		private refreshGroup(name: string, animations: Animation[], group: Group) {
			let card = this.cards.get(name)!;
			if (!card) {
				this.insertAdjacentHTML('beforeend', `<vtbag-ic-group name="${name}"></vtbag-ic-group>`);
				card = this.lastElementChild! as VtbagIcGroupElement;
				card.group = group;
				this.cards.set(name, card);
			}
			if (
				card.animations.length !== animations.length ||
				card.animations.some((a, i) => a !== animations[i])
			) {
				card.animations = animations;
			}
		}
	}
	if (!customElements.get('vtbag-ic-group-list'))
		customElements.define('vtbag-ic-group-list', ICGroupList);
</script>
