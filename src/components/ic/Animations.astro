---
import Scope from './Scope.astro';
import './ic.css';
import './studio.css';
---

<Scope />
<template id="vtbag-ic-animations">
	<h2 class="ic-label" style="--vtn: label">Inspection Chamber</h2>
	<div class="animations-head" style="--vtn: animations-head">
		<div class="animations-head-main" style="--vtn: animations-head-main">
			<span>View Transitions: <span id="view-transitions">0</span></span>
			<span id="scopes">Scopes:</span>
			<span id="scope-buttons"></span>
		</div>
	</div>
	<div class="scope-container" style="--vtn: scope-container"></div>
</template>
<script>
	import { capture } from './capture';
	import { getElementSelector } from './element-selector';
	import { type Group } from './group';
	import { highlight } from './highlight';
	import { ledGroup } from './led-group';
	import { key } from './scope';
	import { allRoots } from '@/css';

	const moduleGroupMaps = new Map<Element, Map<string, Group>>();

	class ICAnimations extends HTMLElement {
		#initialized = false;
		#throttleReRender = false;
		groupMaps: Map<Element, Map<string, Group>>;
		#scopes = new Map<HTMLElement, VtbagIcScopeElement>();
		#observer?: ResizeObserver;
		#rootDocument?: Document;

		constructor() {
			super();
			this.groupMaps = moduleGroupMaps;
			self.addEventListener('ic-about-to-finish', (e) => {
				const root = (e as CustomEvent).detail.root;
				const scopeKey = key(root);
				const scope = this.#scopes.get(scopeKey)!;
				scope && (scope.animations = []);
				this.#scopes.delete(scopeKey);
				scope?.remove();
				allRoots.delete(root);
				parent.document.documentElement.classList.remove('action');
				this.renderHead();
				this.updateAnimationsHead();
			});
		}

		disconnectCallback() {
			this.#observer?.disconnect();
		}

		connectedCallback() {
			this.#observer = new ResizeObserver(([entry]) => {
				const { inlineSize: w, blockSize: h } = entry.contentBoxSize[0] ?? entry.contentRect;
				const orientation = w > h ? 'landscape' : 'portrait';
				if (orientation !== document.documentElement.dataset.orientation) {
					document.documentElement.dataset.orientation = orientation;
				}
			});
			this.#observer.observe(this.parentElement!);

			if (this.#initialized) return;
			this.#initialized = true;

			this.appendChild(
				(document.getElementById('vtbag-ic-animations') as HTMLTemplateElement).content.cloneNode(
					true
				)
			);
			this.querySelector<HTMLSpanElement>('#scopes')!.style.display = 'none';
			this.querySelector<HTMLDivElement>('div.animations-head')!.insertAdjacentHTML(
				'beforeend',
				ledGroup({
					className: 'freeze',
					groupName: 'freeze',
					checked: 'freeze',
					alternatives: [
						{
							label: 'Freeze',
							value: 'freeze',
							id: 'freeze',
						},
						{
							label: 'Next',
							value: 'next',
							id: 'next',
						},
						{
							label: 'Run',
							value: 'run',
							id: 'run',
						},
					],
				})
			);
			this.querySelector('.freeze')!.addEventListener('click', (e) => {
				const clicked = e.target as HTMLInputElement;
				if (clicked.tagName !== 'INPUT') return;
				const freezeOption = this.querySelector<HTMLInputElement>(
					'input[name="freeze"]:checked'
				)?.value;
				if (freezeOption) {
					if (freezeOption === 'freeze' && this.#scopes.size === 0) {
						this.refreshAnimations(this.#rootDocument!.getAnimations())!;
						return;
					}
					this.querySelectorAll<HTMLInputElement>(
						`.scope-container input[value=${freezeOption}]`
					).forEach((input) => {
						const top = input.closest('.input-led-group') as HTMLDivElement;
						top.dataset.save = top.querySelector<HTMLInputElement>('input:checked')!.value;
						input.click();
					});
				} else {
					this.querySelectorAll<HTMLInputElement>(
						`.scope-container input[value=${freezeOption}]`
					).forEach((input) => {
						const top = input.closest('.input-led-group') as HTMLDivElement;
						const saved = top.dataset.save;
						if (saved === input.value) {
							input.click();
						}
					});
				}
				this.updateAnimationsHead();
			});
			addEventListener('ic-after-capture-new', this.mayRender);
			addEventListener('ic-animation-start', this.mayRender);

			this.querySelector<HTMLSelectElement>('#scope-buttons')!.addEventListener('click', (e) => {
				const button = e.target as HTMLButtonElement;
				if (button.tagName === 'BUTTON') {
					const scope = [...this.#scopes.values()].find((s) => s.path === button.value);
					highlight(scope);
				}
			});
		}

		mayRender = (e: Event) => {
			const detail = (e as CustomEvent).detail;
			let again = false;
			if (this.#throttleReRender) {
				again = true;
				return;
			}

			this.#rootDocument = detail.root.ownerDocument;

			this.animatedRender();

			requestAnimationFrame(() => {
				this.#throttleReRender = false;
				if (again) {
					this.animatedRender();
				}
				again = false;
			});
			this.#throttleReRender = true;
		};

		animatedRender() {
			this.render();
		}

		render() {
			if (this.isConnected) {
				if (!this.querySelector<HTMLInputElement>('#run')?.checked) {
					this.refreshAnimations(this.#rootDocument!.getAnimations())!;
				}
				this.renderHead();
			}
		}

		private renderHead() {
			const firstScopeFreeze = this.querySelector<HTMLElement>('.scope-container .freeze');
			const newDisplay = this.#scopes.size <= 1 ? 'none' : 'flex';
			if (firstScopeFreeze && firstScopeFreeze.style.display !== newDisplay) {
				firstScopeFreeze.style.display = newDisplay;
			}
			firstScopeFreeze?.closest('vtbag-ic-scope')!.updateScopeHead();

			const scopeContainer = this.querySelector<HTMLDivElement>('div.scope-container')!;
			this.querySelector<HTMLSpanElement>('#view-transitions')!.innerText = '' + this.#scopes.size;
			this.querySelector<HTMLSpanElement>('#scopes')!.style.display =
				this.#scopes.size > 1 ? 'inline' : 'none';

			const buttons = this.querySelector('#scope-buttons')!;
			buttons.innerHTML = '';
			[...this.#scopes.values().map((s) => s.path)]
				.sort((a, b) => a.localeCompare(b))
				.forEach((path) => {
					buttons.insertAdjacentHTML('beforeend', `<button value="${path}">${path}</button>`);
				});

			const sorted = [...scopeContainer.children].sort((a, b) =>
				a.querySelector('span')!.innerText.localeCompare(b.querySelector('span')!.innerText)
			);

			if ('moveBefore' in Element.prototype)
				sorted.forEach((s) => scopeContainer.moveBefore(s, null));
			else sorted.forEach((s) => scopeContainer.appendChild(s));
		}

		refreshAnimations(animations: Animation[]) {
			const newScopes = new Map<HTMLElement, Animation[]>();

			animations.forEach((a) => {
				if (
					a.effect?.pseudoElement?.startsWith('::view-transition') &&
					// todo: deal with other types of animation
					a.effect?.target
				) {
					if (a.constructor.name !== 'CSSAnimation') console.log('!!!', a);
					const scope = a.effect!.target!;
					let animations = newScopes.get(scope);
					if (!animations) {
						animations = [];
						newScopes.set(scope, animations);
					}
					animations.push(a);
				}
			});
			console.log('scopes in getAnimations()', newScopes);

			newScopes.forEach((animations, element) => {
				let scope = this.#scopes.get(key(element))!;
				if (!scope) {
					scope = document.createElement('vtbag-ic-scope');
					scope.init(element, this.groupMaps.get(key(element))!.get('@')!, animations);
					this.#scopes.set(key(element), scope);
					this.querySelector<HTMLDivElement>('div.scope-container')!.appendChild(scope);
				}
				if (
					scope.animations?.length !== animations.length ||
					scope.animations.some((a, i) => a !== animations[i])
				) {
					scope.animations = animations;
				}
			});
			return newScopes;
		}

		updateAnimationsHead() {
			const color = { red: this.#scopes.size > 0, green: this.#scopes.size === 0 };

			this.#scopes.forEach(
				(scope) =>
					(color[
						scope.querySelector<HTMLInputElement>(`input[value^="run"]`)?.checked ? 'red' : 'green'
					] = false)
			);
			this.querySelectorAll('.animations-head input[name=freeze]').forEach((e) =>
				e.classList.remove('red', 'orange')
			);
			if (color.red)
				this.querySelector('.animations-head input[name=freeze]:checked')!.classList.add('red');
			if (color.red === color.green) {
				this.querySelector('.animations-head input[name=freeze]:checked')!.classList.add('orange');
			}
		}
	}

	if (!customElements.get('vtbag-ic-animations'))
		customElements.define('vtbag-ic-animations', ICAnimations);

	['ic-before-capture-old', 'ic-before-capture-new'].forEach((eventName) =>
		self.addEventListener(eventName, (e) => {
			const transitionRoot = (e as CustomEvent).detail.root;
			if (transitionRoot.tagName === 'HTML')
				parent.document.documentElement.classList.add('action');
			const transitionRootKey = key(transitionRoot);
			const groups =
				moduleGroupMaps.get(transitionRootKey) ??
				new Map<string, Group>([
					['@', { name: '@', className: '', children: [], ancestor: false }],
				]);
			const sheet = capture(transitionRoot, groups);
			moduleGroupMaps.set(transitionRootKey, groups);

			const head = transitionRoot.ownerDocument.head;
			head.insertAdjacentHTML(
				'beforeend',
				`<style id="vtbag-ic-temp-style-${CSS.escape(getElementSelector(transitionRoot))}">${sheet}</style>`
			);
		})
	);

	['ic-after-capture-old', 'ic-after-capture-new'].forEach((event) =>
		self.addEventListener(event, (e) => {
			(e as CustomEvent).detail.root.ownerDocument.body
				.querySelector(
					`#vtbag-ic-temp-style-${CSS.escape(getElementSelector((e as CustomEvent).detail.root))}`
				)
				?.remove();
		})
	);

	self.addEventListener('ic-before-capture-new', (e) => {
		const head = (e as CustomEvent).detail.root.ownerDocument.head;
		head.querySelector('#vtbag-ic-persistent-style') ||
			head.insertAdjacentHTML(
				'beforeend',
				`
<style id="vtbag-ic-persistent-style">
	::view-transition-image-pair(*),
	::view-transition-old(*),
	::view-transition-new(*) {
	--vtbag-ic-only-child: initial;

}
::view-transition-image-pair(*):only-child,
::view-transition-old(*):only-child,
::view-transition-new(*):only-child {
	--vtbag-ic-only-child: "1";
}
</style>
`
			);
	});
</script>
