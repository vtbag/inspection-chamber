---
import Pseudo from './Pseudo.astro';
import GroupList from './GroupList.astro';
---

<Pseudo />
<GroupList />
<script>
	import {
		getCurrentViewTransition,
		mayStartViewTransition,
	} from '@vtbag/utensil-drawer/may-start-view-transition';
	import { getElementSelector } from './element-selector';
	import { type Group, isSorted } from './group';
	import { highlight } from './highlight';
	import { ledGroup, type LEDs } from './led-group';
	import { slider, setMaxValue, setCurrentValue } from './slider';
	import { addBlinds } from './blinds';

	class ICScope extends HTMLElement {
		#scope: HTMLElement | null = null;
		#rootGroup: Group | undefined = undefined;
		#animations: Animation[] = [];
		#path: string | undefined = undefined;
		#dirty = false;
		static #nextId = 0;
		#id = ICScope.#nextId++;
		#sortLEDs: LEDs;
		#sizeLEDs: LEDs;
		#freezeLEDs: LEDs;
		#timings: Map<Animation, ComputedEffectTiming> = new Map();
		#longestDuration?: number;
		#clickTrack: Animation | undefined;
		#observer?: ResizeObserver;
		#resizeToggle: boolean = false;
		#main?: VtbagIcAnimationsElement;

		constructor() {
			super();

			console.log('Constructor for Scope');
			this.#sortLEDs = {
				className: 'sort',
				groupName: `scope-sort-${this.#id}`,
				checked: 'alpha',
				alternatives: [
					{
						label: 'Alphabetical',
						value: 'alpha',
						id: `scope-sort-${this.#id}-alpha`,
					},
					{
						label: 'Paint Order',
						value: 'paint-order',
						id: `scope-sort-${this.#id}-paint-order`,
					},
				],
			};
			this.#sizeLEDs = {
				className: 'size',
				groupName: `scope-size-${this.#id}`,
				checked: 'detailed',
				alternatives: [
					{
						label: 'Compact',
						value: 'compact',
						id: `scope-size-${this.#id}-compact`,
					},
					{
						label: 'Detailed',
						value: 'detailed',
						id: `scope-size-${this.#id}-detailed`,
					},
				],
			};
			this.#freezeLEDs = {
				className: 'freeze',
				groupName: `freeze-${this.#id}`,
				checked: 'none',
				alternatives: [
					{
						label: 'Freeze',
						value: 'freeze',
						id: `freeze-${this.#id}`,
					},
					{
						label: 'Next',
						value: 'next',
						id: `next${this.#id}`,
					},
					{
						label: 'Run',
						value: 'run',
						id: `run-${this.#id}`,
					},
				],
			};
		}

		disconnectedCallback() {
			this.#animations = [];
			this.#observer?.disconnect();
		}

		connectedMoveCallback() {}
		connectedCallback() {
			console.log('connected scope ' + this.#scope);
			this.#observer = new ResizeObserver(() => {
				if (this.#resizeToggle || getCurrentViewTransition()) {
					return;
				}
				this.#resizeToggle = true;
				requestAnimationFrame(() => {
					addBlinds(this.querySelector('.scope-head')!, 'div', 'head-blind', 'shb', 'blind');
					this.#resizeToggle = false;
				});
			});
			this.#observer.observe(this);
			this.render();
		}

		get size() {
			return this.#sizeLEDs.checked;
		}

		get path() {
			return (this.#path ??= getElementSelector(this.#scope!));
		}

		get scopeId() {
			return this.#id;
		}
		get element() {
			return this.#scope;
		}

		init(element: HTMLElement, root: Group, animations: Animation[]) {
			this.#scope = element;
			this.#rootGroup = root;
			this.#animations = animations;
			this.#path = undefined;
			this.#dirty = true;
		}

		get animations() {
			return this.#animations;
		}
		set animations(value: Animation[]) {
			if (value.some((a) => !this.#animations.includes(a))) {
				this.#animations = [...new Set<Animation>([...this.#animations, ...value])];
				this.#dirty = true;
				this.render();
			}
		}

		render() {
			if (this.isConnected && this.#dirty) {
				this.#main = this.closest('vtbag-ic-animations')!;
				this.#dirty = false;
				let html = `<div class="scope-head"><div class="scope-head-main"><h3 class="heading">Scope <span class="scope-path">${this.path}</span></h3>`;

				html += this.topLevelGroups(this.#rootGroup!, true);
				html += '</div>';

				html += slider(`slider-${this.#id}`, `slider-${this.#id}`);
				if (!isSorted(this.#rootGroup!)) {
					html += ledGroup(this.#sortLEDs);
				}
				html += ledGroup(this.#sizeLEDs);

				this.#freezeLEDs.checked =
					this.#main!.querySelector<HTMLInputElement>(
						'.animations-head input[name="freeze"]:checked'
					)?.value ?? 'none';

				html += ledGroup(this.#freezeLEDs);
				html += '</div>';

				this.innerHTML = html;

				this.querySelectorAll<HTMLInputElement>(`input[name^="freeze"]`).forEach((e) =>
					e.classList.remove('orange', 'red')
				);
				if (this.querySelector<HTMLInputElement>(`input[value="next"]`)!.checked) {
					const input = this.querySelector<HTMLInputElement>(`input[value="freeze"]`)!;
					input.click();
					input.clientHeight;
				}

				if (this.querySelector<HTMLInputElement>(`input[value="freeze"]`)!.checked) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.add(
						'red'
					);
					this.animations.forEach((a) => {
						a.pause();
					});
				}

				this.#main!.updateAnimationsHead();
				this.updateScopeHead();

				this.insertAdjacentHTML(
					'beforeend',
					'<vtbag-ic-pseudo name="::view-transition"></vtbag-ic-pseudo>'
				);

				const groupList = document.createElement('vtbag-ic-group-list') as VtbagIcGroupListElement;
				groupList.animations = this.animations;
				this.appendChild(groupList);

				const error = (e: any) => console.error('View Transition error:', e, ' Cause:', e.cause);

				this.setupSlider();
				this.addSortListener(groupList, error);
				this.addResizeListener(error);
				this.addFreezeListener();
				this.addButtonListener();
			}
		}
		setupSlider() {
			this.#animations.forEach((a) => this.#timings.set(a, a.effect!.getComputedTiming()));
			this.#longestDuration = this.#animations.reduce(
				(max, a) => Math.max(max, this.#timings.get(a)!.duration as number),
				0
			);
			const slowMo = this.#main!.querySelector<HTMLInputElement>(
				'input[name="slow-mo"]:checked'
			)?.value;
			this.#clickTrack = this.#scope?.animate([{ top: 0 }, { top: 0 }], {
				duration: this.#longestDuration,
				pseudoElement: '::view-transition',
				playbackRate: slowMo === 'normal' ? 1 : slowMo === 'slow' ? 0.1 : 0.01,
			})!;
			this.#animations.push(this.#clickTrack);
			if (this.#animations[0].playState === 'paused') this.#clickTrack.pause();
			setMaxValue(
				`slider-${this.#id}`,
				this.#longestDuration,
				this.#animations[0].currentTime as number,
				(e) => {
					this.animations.forEach((a) => {
						a.currentTime = Math.min(
							parseInt((e.target as HTMLInputElement).value),
							this.#longestDuration! - 1
						);
					});
				}
			);
		}
		updateScopeHead() {
			addBlinds(this.querySelector('.scope-head')!, 'div', 'head-blind', 'shb', 'blind');
		}
		private addButtonListener() {
			[this.children[0], this.children[2]].forEach((x) =>
				x.addEventListener('click', (e) => {
					const button = e.target as HTMLButtonElement;
					let id: string | undefined;
					if (button.tagName === 'BUTTON' || button.tagName === 'H3') {
						id = button.dataset.group;
						if (!id) return;
					} else {
						return;
					}
					const group =
						id === '1'
							? (this.querySelector('.scope-head-main') as HTMLDivElement)
							: [...this.querySelectorAll<VtbagIcGroupElement>('vtbag-ic-group')].find(
									(g) => g.group?.preOrder == id
								);

					highlight(group);
				})
			);
		}

		private addResizeListener(error: (e: any) => void) {
			this.querySelector('.input-led-group.size')?.addEventListener('change', (e) => {
				this.#sizeLEDs.checked = (e.target as HTMLInputElement).value;

				const styles: string[] = [];
				document.querySelectorAll<VtbagIcGroupElement>('vtbag-ic-group').forEach((g) => {
					styles.push(`
::view-transition-group(${g.style.getPropertyValue('--vtn')}) {
	outline: ${g.style.outline};
	border-radius: 4px;	
}`);
				});
				document.head.insertAdjacentHTML(
					'beforeend',
					`
<style data-vtbag="size-vt">
${styles.join('\n')}
</style>`
				);
				const transition = mayStartViewTransition!(
					{
						update: () => {
							const compact =
								this.querySelector<HTMLInputElement>(`input[value="compact"]`)!.checked;
							this.querySelectorAll<VtbagIcGroupElement>(
								'vtbag-ic-group vtbag-ic-pseudo[name="group"]'
							).forEach((pseudo) => pseudo.classList[compact ? 'add' : 'remove']('compact'));
						},
						types: ['resize'],
					},
					{ useTypesPolyfill: 'always' }
				);
				transition.updateCallbackDone.catch(error);
				transition.ready.catch(error);
				transition.finished.then(() =>
					document.head.querySelector('style[data-vtbag="size-vt"]')?.remove()
				);
			});
		}

		private addSortListener(groupList: VtbagIcGroupListElement, error: (e: any) => void) {
			this.querySelector('.input-led-group.sort')?.addEventListener('change', (e) => {
				this.#sortLEDs.checked = (e.target as HTMLInputElement).value;
				const transition = mayStartViewTransition!(
					{
						update: () => {
							const alpha = this.querySelector<HTMLInputElement>(`input[value="alpha"]`)!.checked;
							groupList.sort(alpha ? 'alpha' : 'paint-order');
							const children = this.querySelector('.children')!;
							children.insertAdjacentHTML('afterend', this.topLevelGroups(this.#rootGroup!, alpha));
							children.remove();
						},
						types: ['sort'],
					},
					{ useTypesPolyfill: 'always' }
				);
				transition.updateCallbackDone.catch(error);
				transition.ready.catch(error);
			});
		}

		private addFreezeListener() {
			this.querySelector('.input-led-group.freeze')?.addEventListener('change', (e) => {
				if ((e.target as HTMLElement)?.tagName !== 'INPUT') return;
				if (this.querySelector<HTMLInputElement>(`input[value="freeze"]:checked`)) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)?.classList.add(
						'red'
					);
					this.#animations.forEach((a) => a.pause());
				}
				if (
					this.querySelector<HTMLInputElement>(
						`input[value="run"]:checked, input[value="next"]:checked`
					)
				) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.remove(
						'red'
					);
					const speed = this.#main!.querySelector<HTMLInputElement>(
						'input[name="slow-mo"]:checked'
					)?.value;
					this.#animations.forEach((a) => {
						(a.currentTime === this.#longestDuration ||
							this.querySelector<HTMLInputElement>(`input[value="next"]:checked`)) &&
							(a.currentTime = this.#longestDuration! - 1);
						a.playbackRate = speed === 'normal' ? 1 : speed === 'slow' ? 0.1 : 0.01;
						a.play();
						this.autoMoveSlider();
					});
				}
				this.#main!.updateAnimationsHead();
			});
		}

		autoMoveSlider() {
			const now = this.#clickTrack!.currentTime! as number;
			setCurrentValue(`slider-${this.#id}`, now);
			if (now < this.#longestDuration!) requestAnimationFrame(this.autoMoveSlider.bind(this));
		}

		topLevelGroups(rootGroup: Group, alpha = true) {
			let html = '<div class="children">Groups: ';
			const buttons = [...rootGroup.children];

			if (alpha) {
				buttons.sort((a, b) =>
					a.name.replace(/^-vtbag-/, '').localeCompare(b.name.replace(/^-vtbag-/, ''))
				);
			}

			buttons.forEach((g) => {
				const name = g.name.replace(
					/-vtbag-match-element-([0-9]+)/,
					(_, num) => `match-element<sup>(${num})</sup>`
				);
				html += `<button data-group="${g.preOrder}" style="--vtn: b-${this.#id}-${g.preOrder}; border: 2px solid oklch(0.7 0.07 ${(360 / (rootGroup.postOrder! - rootGroup.preOrder! + 1)) * g.preOrder!}deg / 1)">${name}</button>`;
			});
			html += '</div>';
			return html;
		}
	}
	if (!customElements.get('vtbag-ic-scope')) customElements.define('vtbag-ic-scope', ICScope);
</script>
