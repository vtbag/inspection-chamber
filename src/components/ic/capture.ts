import { namedElements } from '@/css';
import { getElementSelector } from './element-selector';
import { effectiveZIndex } from './stacking-context';
import type { Group } from './group';

type SparseDOMNode = {
	viewTransitionName: string;
	viewTransitionGroup?: string;
	viewTransitionClass?: string;
	style: CSSStyleDeclaration;
	element: Element;
	pseudoElement?: string;
	zIndex?: number;
	children: SparseDOMNode[];
};

const ids = new WeakMap<Element, string>();
let idCount = 0;

export function capture(
	transitionRoot: HTMLElement,
	groups: Map<string, Group>
): string {
	let sheet = '';
	console.log('transitionRoot :>> ', transitionRoot);
	const seen = new Set<string>();
	const elementMap = new Map<Element, SparseDOMNode>();
	const sparseDOM: SparseDOMNode[] = [];

	const { elements: named } = namedElements(transitionRoot);

	let rootNode: SparseDOMNode = {
		viewTransitionName: 'none',
		element: transitionRoot,
		style: getComputedStyle(transitionRoot),
		children: [],
	};
	elementMap.set(transitionRoot, rootNode);

	named.forEach(({ element, pseudoElement }) => {
		const path = getElementSelector(element);
		// element.dataset.vtbagIcId = path;
		const key = path + (pseudoElement ? pseudoElement : '');
		if (seen.has(key)) return;
		seen.add(key);

		const style = getComputedStyle(element, pseudoElement);
		if (style.viewTransitionName === 'none') return;
		if (style.display === 'none') return;

		const potentiallyRenamed = renameAutoGeneratedNames();
		//addBackLink();

		const node = {
			element,
			pseudoElement,
			viewTransitionName: potentiallyRenamed,
			viewTransitionGroup: style.viewTransitionGroup,
			viewTransitionClass: style.viewTransitionClass,
			style,
			children: [],
		};
		sparseDOM.push(node);
		if (!pseudoElement) elementMap.set(element, node);

		function renameAutoGeneratedNames() {
			const name = style.viewTransitionName;
			console.log('style.viewTransitionName :>> ', style.viewTransitionName);
			if (name === 'match-element' || (name === 'auto' && !element.id)) {
				let id = ids.get(element);
				if (!id) {
					id = `-vtbag-${name}-${++idCount}`;
					ids.set(element, id);
				}
				sheet += `${key} { view-transition-name: ${id} !important}\n`;
				return id;
			}
			return name;
		}

		function addBackLink() {
			const withBackLink =
				(style.backdropFilter !== 'none' ? style.backdropFilter + ' ' : '') +
				`url(#vtbag-ic-${key})`;
			sheet += `${key} { backdrop-filter: ${withBackLink}}\n`;
		}
	});

	rootNode = elementMap.get(transitionRoot)!;
	sparseDOM.forEach(linkToParent);
	sort(rootNode);

	nestGroups(rootNode, groups.get('@')!, groups.get('@')!, groups);
	
	return sheet;

	function linkToParent(node: SparseDOMNode) {
		if (node.style?.contain.includes('view-transition')) return;
		if (node.pseudoElement) {
			let parent = elementMap.get(node.element);
			if (parent) {
				if (!parent.style?.contain.includes('view-transition')) {
					parent.children.push(node);
					node.zIndex = effectiveZIndex(node.element, node.style, parent.style);
				}
				return;
			} else {
				const parentStyle = getComputedStyle(node.element);
				parent = {
					children: [],
					element: node.element,
					viewTransitionName: 'none',
					style: parentStyle,
				};
				elementMap.set(node.element, parent);
				if (parentStyle.contain.includes('view-transition')) return;

				parent.children.push(node);
				elementMap.set(node.element, parent);
				node = parent;
				// fall through
			}
		}
		let me = node;
		let current = node.element;
		while (current !== transitionRoot) {
			const parent = elementMap.get(current.parentElement!);
			if (parent) {
				if (!parent.style?.contain.includes('view-transition')) {
					parent.children.push(me);
					node.zIndex = effectiveZIndex(node.element, node.style, parent.style);
				}
				return;
			}
			current = current.parentElement!;
			const parentStyle = getComputedStyle(current);
			const newParent: SparseDOMNode = {
				children: [],
				element: current,
				style: parentStyle,
				viewTransitionName: 'none',
			};
			elementMap.set(current, newParent);
			if (parentStyle.contain.includes('view-transition')) return;
			newParent.children.push(me);
			me = newParent;
		}
	}

	function sort(node: SparseDOMNode) {
		node.children.forEach(sort);
		node.children.sort((a, b) =>
			a === b
				? 0
				: a.element.compareDocumentPosition(b.element) & Node.DOCUMENT_POSITION_PRECEDING
					? 1
					: -1
		);
		for (let i = 0; i < node.children.length - 1; ++i) {
			const pseudo = node.children[i].pseudoElement;
			if (pseudo)
				if (pseudo === '::after') node.children.push(node.children.splice(i, 1)[0]);
				else node.children.unshift(node.children.splice(i, 1)[0]);
		}
		node.children.sort((a, b) => a.zIndex! - b.zIndex!);
	}
}

function nestGroups(
	node: SparseDOMNode,
	parent: Group,
	container: Group,
	groups: Map<string, Group>
) {
	if (node.viewTransitionName === 'none') {
		node.children.forEach((child) => nestGroups(child, parent, container, groups));
	} else {
		let group = groups.get(node.viewTransitionName);
		if (!group) {
			//console.log('new group', node.viewTransitionName);
			group = {
				children: [],
				name: node.viewTransitionName,
				className: node.viewTransitionClass!,
				ancestor: true,
			};
			groups.set(node.viewTransitionName, group);
			if (node.viewTransitionGroup === 'nearest') {
				parent.children.push(group);
			} else if (node.viewTransitionGroup === 'normal' || node.viewTransitionGroup === 'contain') {
				container.children.push(group);
			} else {
				const namedGroup = groups.get(node.viewTransitionGroup!);
				if (namedGroup?.ancestor) namedGroup.children.push(group);
				else groups.get('@')!.children.push(group);
			}
		}
		node.children.forEach((child) =>
			nestGroups(child, group, node.viewTransitionGroup !== 'normal' ? group : container, groups)
		);
		group.ancestor = false;
	}
}
export function print(group: Group, depth = 0) {
	console.log(`${' '.repeat(depth * 2)}- ${group.name}`);
	group.children.forEach((child) => print(child, depth + 1));
}
