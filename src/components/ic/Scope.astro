---
import Pseudo from './Pseudo.astro';
import GroupList from './GroupList.astro';
import Identify from '@/components/ic/Identify.astro';
---

<Pseudo />
<GroupList />
<Identify />

<script>
	import {
		getCurrentViewTransition,
		mayStartViewTransition,
	} from '@vtbag/utensil-drawer/may-start-view-transition';
	import { deriveCSSSelector } from './element-selector';
	import { color, gid, type Group, isSorted, linear } from './group';
	import { highlight } from './highlight';
	import { ledGroup, type LEDs, showLedGroup, hideLedGroup } from './led-group';
	import { slider, setMaxValue, setCurrentValue } from './slider';
	import { addBlinds } from './blinds';
	import { frameToggles } from './multi-frame';
	import { minmax, defaultTransitionDuration } from './minmax';
	import { any } from 'astro:schema';

	let nextId = 0;
	const scopeMap = new WeakMap<HTMLElement, number>();
	class ICScope extends HTMLElement {
		#scope: HTMLElement | null = null;
		#rootGroup: Group | undefined = undefined;
		#animations: Animation[] = [];
		#path: string | undefined = undefined;
		#dirty = false;
		#id = 0;
		#sortLEDs: LEDs;
		#sizeLEDs: LEDs;
		#freezeLEDs: LEDs;
		#timings: Map<Animation, ComputedEffectTiming> = new Map();
		#longestDuration?: number;
		#clickTrack: Animation | undefined;
		#resizeObserver?: ResizeObserver;
		#intersectionObserver?: IntersectionObserver;
		#resizeToggle: boolean = false;
		#animationsElement?: VtbagIcAnimationsElement;
		#frameToggleRefresh?: () => void;
		#raf?: number;
		#resynced: boolean = false;

		constructor() {
			super();

			this.#sortLEDs = {
				className: 'sort',
				groupName: `scope-sort-${this.#id}`,
				checked: 'paint-order',
				alternatives: [
					{
						label: 'Alphabetical',
						value: 'alpha',
						id: `scope-sort-${this.#id}-alpha`,
					},
					{
						label: 'Paint Order',
						value: 'paint-order',
						id: `scope-sort-${this.#id}-paint-order`,
					},
				],
			};
			this.#sizeLEDs = {
				className: 'size',
				independent: true,
				groupName: `scope-size-${this.#id}`,
				checked: 'none',
				alternatives: [
					{
						label: 'Compact',
						value: 'compact',
						id: `scope-size-${this.#id}-compact`,
					},
					{
						label: 'Detailed',
						value: 'detailed',
						id: `scope-size-${this.#id}-detailed`,
					},
				],
			};
			this.#freezeLEDs = {
				className: 'freeze',
				groupName: `freeze-${this.#id}`,
				checked: 'none',
				alternatives: [
					{
						label: 'Freeze',
						value: 'freeze',
						id: `freeze-${this.#id}`,
					},
					{
						label: 'Next',
						value: 'next',
						id: `next${this.#id}`,
					},
					{
						label: 'Run',
						value: 'run',
						id: `run-${this.#id}`,
					},
				],
			};
		}

		disconnectedCallback() {
			this.#animations = [];
			this.#resizeObserver?.disconnect();
			this.#intersectionObserver?.disconnect();
		}

		connectedMoveCallback() {}
		connectedCallback() {
			this.#resizeObserver = new ResizeObserver(() => {
				if (this.#resizeToggle || getCurrentViewTransition()) {
					return;
				}
				this.#resizeToggle = true;
				requestAnimationFrame(() => {
					addBlinds(this.querySelector('.scope-head')!, 'div', 'head-blind', 'shb', 'blind');
					this.#resizeToggle = false;
				});
			});
			this.#resizeObserver.observe(this);
			this.#intersectionObserver = new IntersectionObserver((entries) => {
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						this.animatedRender();
					} else {
						if (this.#raf !== undefined) {
							cancelAnimationFrame(this.#raf);
							console.log('Canceled RAF due to intersection');
							this.#raf = undefined;
						}
					}
				});
			});
			this.#intersectionObserver.observe(this);
			this.render();
		}

		get path() {
			return (this.#path ??= deriveCSSSelector(this.#scope!));
		}

		get scopeId() {
			return this.#id;
		}
		get element() {
			return this.#scope;
		}

		init(element: HTMLElement, root: Group, animations: Animation[]) {
			this.#scope = element;
			this.#rootGroup = root;
			this.#animations = animations;
			this.#path = undefined;
			this.#dirty = true;
			this.#id = scopeMap.get(element) ?? 0;
			if (!this.#id) {
				this.#id = ++nextId;
				scopeMap.set(element, this.#id);
			}
		}

		get animations() {
			return this.#animations;
		}
		set animations(value: Animation[]) {
			if (value.some((a) => !this.#animations.includes(a))) {
				this.#animations = [...new Set<Animation>([...this.#animations, ...value])];
				this.#dirty = true;
				this.render();
			}
		}

		animatedRender() {
			this.#animations.forEach((a) => a.pause());
			mayStartViewTransition!(
				{
					update: () => {
						this.render();
					},
					types: ['vt-entry'],
				},
				{ useTypesPolyfill: 'always', collisionBehavior: 'chaining' }
			);
		}
		render() {
			if (this.isConnected && this.#dirty) {
				this.#animationsElement = this.closest('vtbag-ic-animations')!;
				this.#dirty = false;
				let html = `<div class="scope-head"><div class="scope-head-main"><h3 class="heading">Scope <span class="scope-path">${this.path}</span></h3>`;
				this.setAttribute('data-scope', this.path);
				html += this.allGroupButtons(this.#rootGroup!, false, true);
				html += '</div>';

				html += slider(`slider-${this.#id}`, `slider-${this.#id}`);
				if (!isSorted(this.#rootGroup!)) {
					html += ledGroup(this.#sortLEDs);
				}
				html += ledGroup(this.#sizeLEDs);

				this.#freezeLEDs.checked =
					this.#animationsElement!.querySelector<HTMLInputElement>(
						'.animations-head input[name="freeze"]:checked'
					)?.value ?? 'none';

				html += ledGroup(this.#freezeLEDs);
				html += '</div>';

				this.innerHTML = html;
				const sizer = this.querySelector('.input-led-group.size')! as HTMLElement;
				const sorter = this.querySelector('.input-led-group.sort')! as HTMLElement;
				const children = this.querySelector('.children') as HTMLElement;
				minmax(
					children,
					'minimized',
					'Group names',
					sessionStorage,
					'vtbag-ic-minmax-group-names',
					(input) => {
						input.checked &&
						this.querySelector<HTMLInputElement>('vtbag-ic-pseudo .minmax input:checked')
							? hideLedGroup(sorter)
							: showLedGroup(sorter);
					}
				);
				children.style.display = '';

				this.#frameToggleRefresh = frameToggles(
					this.querySelector<HTMLDivElement>('div.scope-head')!,
					'vtbag-ic-scope'
				);
				this.addEventListener('frame-toggle', () => {
					this.#frameToggleRefresh!();
				});

				this.querySelectorAll<HTMLInputElement>(`input[name^="freeze"]`).forEach((e) =>
					e.classList.remove('orange', 'red')
				);
				if (this.querySelector<HTMLInputElement>(`input[value="next"]`)!.checked) {
					const input = this.querySelector<HTMLInputElement>(`input[value="freeze"]`)!;
					input.click();
					input.clientHeight;
				}

				if (this.querySelector<HTMLInputElement>(`input[value="freeze"]`)!.checked) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.add(
						'red'
					);
					this.animations.forEach((a) => {
						a.pause();
					});
				}

				this.#animationsElement!.updateAnimationsHead();
				this.updateScopeHead();

				this.insertAdjacentHTML(
					'beforeend',
					'<vtbag-ic-pseudo name="::view-transition"></vtbag-ic-pseudo>'
				);

				const pseudoRoot = this.lastElementChild as VtbagIcPseudoElement;
				const groupList = document.createElement('vtbag-ic-group-list') as VtbagIcGroupListElement;
				groupList.style.display = 'none';
				groupList.animations = this.animations;
				pseudoRoot.appendChild(groupList);

				minmax(
					groupList,
					'minimized',
					'Pick pseudo from tree',
					sessionStorage,
					'vtbag-ic-minmax-pseudo-elements',
					(input) => {
						input.checked ? hideLedGroup(sizer) : showLedGroup(sizer);
						input.checked &&
						this.querySelector<HTMLInputElement>('.scope-head-main .minmax input:checked')
							? hideLedGroup(sorter)
							: showLedGroup(sorter);
					}
				);

				groupList.style.display = '';

				const pseudos = [...this.querySelectorAll<VtbagIcPseudoElement>('vtbag-ic-pseudo')].sort(
					(a, b) => (a.icGroup?.group.preOrder ?? -1) - (b.icGroup?.group.preOrder ?? -1)
				);
				pseudos.forEach((pseudo) => pseudo.createTwin());
				pseudos.forEach((pseudo) => parent.__vtbag.ic2?.intersectionObserver?.observe(pseudo.twin));

				const error = (e: any) => console.error('View Transition error:', e, ' Cause:', e.cause);
				this.setupSlider();
				this.addSortListener(groupList, error);
				this.addResizeListener(error);
				this.addFreezeListener();
				this.addButtonListener();
				this.addDetailsListener();
				this.addEventListener('resync', () => this.resync());
			}
		}

		setupSlider() {
			this.#animations.forEach((a) => this.#timings.set(a, a.effect!.getComputedTiming()));
			this.#longestDuration = this.#animations.reduce(
				(max, a) => Math.max(max, this.#timings.get(a)!.endTime as number),
				0
			);
			const slowMo = this.#animationsElement!.querySelector<HTMLInputElement>(
				'input[name="slow-mo"]:checked'
			)?.value;
			this.#clickTrack = this.#scope?.animate([{ top: 0 }, { top: 0 }], {
				duration: this.#longestDuration,
				pseudoElement: '::view-transition',
				playbackRate: slowMo === 'normal' ? 1 : slowMo === 'slow' ? 0.1 : 0.01,
			})!;
			(this.#clickTrack as CSSAnimation & { alias: string }).alias = 'vtbag-ic-click-track';
			this.#animations.push(this.#clickTrack);
			if (this.#animations[0].playState === 'paused') this.#clickTrack.pause();
			const details =
				this.#animationsElement!.querySelector<VtbagIcPseudoDetailsElement>(
					'vtbag-ic-pseudo-details'
				);
			const detailedPseudo = details?.querySelector('h3');
			setMaxValue(
				`slider-${this.#id}`,
				this.#longestDuration,
				this.#animations[0].currentTime as number, // todo: better minimum of all animations?
				(e) => {
					const time = parseInt((e.target as HTMLInputElement).value, 10);
					this.animations.forEach(
						(a) => (a as Animation & { stopped?: boolean }).stopped || (a.currentTime = time)
					);
					if (detailedPseudo?.innerText.startsWith(`${this.path}::view-transition`)) {
						setCurrentValue('details-slider', time);
					} else {
						this.#animationsElement!.movePseudos();
					}
				}
			);
			this.resync();
		}

		resync() {
			if (this.#resynced) return;
			this.#resynced = true;
			this.#animations
				.filter(
					(a) =>
						a.playState === 'paused' && a.effect?.pseudoElement?.startsWith('::view-transition')
				)
				.forEach((a) => {
					const now = a.currentTime;
					a.currentTime === 0 ? a.currentTime++ : (a.currentTime as number)--;
					requestAnimationFrame(() => {
						a.currentTime = now;
						this.#resynced = false;
					});
				});
		}

		updateScopeHead() {
			addBlinds(this.querySelector('.scope-head')!, 'div', 'head-blind', 'shb', 'blind');
			this.#frameToggleRefresh!();
		}

		private addButtonListener() {
			this.addEventListener('click', async (e) => {
				if ((e.target as HTMLElement).classList?.contains('group-content')) {
					(e.target as HTMLElement).lastElementChild?.classList.toggle('compact');
					return;
				}
				const button = (e.target as HTMLElement)?.closest('*[data-group]') as HTMLElement;
				if (!button) return;
				const id = button.dataset.group;
				const group =
					button.tagName !== 'BUTTON'
						? (this.querySelector<VtbagIcGroupElement>(
								`vtbag-ic-group:has(button[data-group="${id}"])`
							) ?? (this.querySelector('.scope-head-main') as HTMLDivElement))
						: this.querySelector<VtbagIcGroupElement>(`vtbag-ic-group:has(h3[data-group="${id}"])`);
				if (button.tagName === 'BUTTON') {
					const minimized = this.querySelector<HTMLInputElement>(
						'vtbag-ic-pseudo[name="::view-transition"] .minmax input:checked'
					);
					if (minimized) {
						minimized.click();
						await new Promise((r) => setTimeout(r, defaultTransitionDuration));
					}
				}
				highlight(group);
			});
			this.addButtonEnterLeaveListeners();
		}

		private addDetailsListener() {
			this.addEventListener('click', async (e) => {
				const span = e.target as HTMLElement as HTMLSpanElement;
				if (span.tagName !== 'SPAN' || !span.classList.contains('name')) return;
				const pseudo = span.closest('vtbag-ic-pseudo') as VtbagIcPseudoElement;
				pseudo &&
					document
						.querySelector<VtbagIcPseudoDetailsElement>('vtbag-ic-pseudo-details')
						?.set(pseudo.dataset.link!);
			});
		}

		private addButtonEnterLeaveListeners() {
			['pointerenter', 'pointerleave'].forEach((name) =>
				this.querySelectorAll<HTMLButtonElement>('button[data-group]').forEach((b) =>
					b.addEventListener(name, (e) => {
						const button = e.target as HTMLButtonElement;
						if (button.tagName !== 'BUTTON') return;
						const id = button.dataset.group;
						if (!id) return;
						this.querySelector<VtbagIcGroupElement>(
							`vtbag-ic-group:has(h3[data-group="${id}"]) .frame input`
						)?.click();
					})
				)
			);
		}
		private addResizeListener(error: (e: any) => void) {
			this.querySelector('.input-led-group.size')?.addEventListener('change', () => {
				const compact = this.querySelector<HTMLInputElement>(`input[value="compact"]`)!.checked;
				const detailed = this.querySelector<HTMLInputElement>(`input[value="detailed"]`)!.checked;
				if (!detailed && !compact) return;

				const styles: string[] = [];
				document.querySelectorAll<VtbagIcGroupElement>('vtbag-ic-group').forEach((g) => {
					styles.push(`
::view-transition-group(${g.style.getPropertyValue('--vtn')}) {
--vtbag-ic-group-color: ${g.style.getPropertyValue('--vtbag-ic-group-color')};
	outline: ${g.style.outline};
	border-radius: 4px;	
}`);
				});
				document.head.insertAdjacentHTML(
					'beforeend',
					`
<style data-vtbag="size-vt">
${styles.join('\n')}
</style>`
				);

				const transition = mayStartViewTransition!(
					{
						update: () => {
							this.querySelectorAll<VtbagIcGroupElement>(
								'vtbag-ic-group vtbag-ic-pseudo[name="group"]'
							).forEach((pseudo) => pseudo.classList.toggle('compact', compact));
						},
						types: ['resize'],
					},
					{ useTypesPolyfill: 'always' }
				);
				transition.updateCallbackDone.catch(error);
				transition.ready.catch(error);
				transition.finished.then(() => {
					document.head.querySelector('style[data-vtbag="size-vt"]')?.remove();
					this.querySelector<HTMLInputElement>('.input-led-group.size input:checked')?.click();
				});
			});
		}

		private addSortListener(groupList: VtbagIcGroupListElement, error: (e: any) => void) {
			this.querySelector('.input-led-group.sort')?.addEventListener('change', (e) => {
				this.#sortLEDs.checked = (e.target as HTMLInputElement).value;
				const transition = mayStartViewTransition!(
					{
						update: () => {
							const alpha = this.querySelector<HTMLInputElement>(`input[value="alpha"]`)!.checked;
							groupList.sort(alpha ? 'alpha' : 'paint-order');
							const children = this.querySelector('.children')!;
							children.insertAdjacentHTML(
								'afterend',
								this.allGroupButtons(this.#rootGroup!, alpha)
							);
							const news = children.nextElementSibling as HTMLElement;
							children.remove();
							[...news.children].forEach((element) =>
								element.classList.toggle(
									'in-view',
									children
										.querySelector(`[data-group="${element.getAttribute('data-group')}"]`)
										?.classList.contains('in-view') ?? false
								)
							);
							this.addButtonEnterLeaveListeners();
						},
						types: ['sort'],
					},
					{ useTypesPolyfill: 'always' }
				);
				transition.updateCallbackDone.catch(error);
				transition.ready.catch(error);
			});
		}

		private addFreezeListener() {
			this.querySelector('.input-led-group.freeze')?.addEventListener('change', (e) => {
				if ((e.target as HTMLElement)?.tagName !== 'INPUT') return;

				if (this.querySelector<HTMLInputElement>(`input[value="freeze"]:checked`)) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)?.classList.add(
						'red'
					);
					this.#animations.forEach((a) => a.pause());
				}
				if (this.#raf !== undefined) {
					cancelAnimationFrame(this.#raf);
					console.log('Canceled RAF');
					this.#raf = undefined;
				}
				if (this.querySelector<HTMLInputElement>(`input[value="run"]:checked`)) {
					this.#animationsElement
						?.querySelector<HTMLInputElement>('#reset-stopped-animations')
						?.click();

					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.remove(
						'red'
					);
					const speed = this.#animationsElement!.querySelector<HTMLInputElement>(
						'input[name="slow-mo"]:checked'
					)?.value;
					this.#animations.forEach((a) => {
						a.currentTime === this.#longestDuration && (a.currentTime = this.#longestDuration! - 1);
						a.playbackRate = speed === 'normal' ? 1 : speed === 'slow' ? 0.1 : 0.01;
						'stopped' in a || a.play();
					});
					this.autoMoveSlider();
				}
				if (this.querySelector<HTMLInputElement>(`input[value="next"]:checked`)) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.remove(
						'red'
					);
					this.#animations.forEach((a) => {
						a.finish();
					});
				}
				this.#animationsElement!.updateAnimationsHead();
			});
		}

		autoMoveSlider() {
			const now = this.#clickTrack!.currentTime! as number;
			setCurrentValue(`slider-${this.#id}`, now);
			this.#animationsElement!.movePseudos();
			if (now < this.#longestDuration!) {
				this.#raf = requestAnimationFrame(() => this.#raf && this.autoMoveSlider());
			}
			if (
				this.#animationsElement!.querySelector<VtbagIcPseudoDetailsElement>(
					'vtbag-ic-pseudo-details'
				)
					?.querySelector('h3')
					?.innerText.startsWith(`${this.path}::view-transition`)
			) {
				setCurrentValue('details-slider', now);
			}
		}

		allGroupButtons(rootGroup: Group, alpha = true, hide = false) {
			let html = `<div class="children" style="display:${hide ? 'none' : 'block'}">Groups: `;
			const buttons = linear(rootGroup); //[...rootGroup.children];

			if (alpha) {
				buttons.sort((a, b) =>
					a.name.replace(/^-vtbag-/, '').localeCompare(b.name.replace(/^-vtbag-/, ''))
				);
			}

			buttons.forEach((g) => {
				if (g.parent === undefined) return;
				const name = g.name.replace(
					/-vtbag-match-element-([0-9]+)/,
					(_, num) => `match-element<sup>(${num})</sup>`
				);
				html += `<button data-group="${gid(g)}" style="--vtn: b-${this.#id}-${gid(g)}; border: 2px solid ${color(g)}">${name}</button>`;
			});
			html += '</div>';
			return html;
		}
	}
	if (!customElements.get('vtbag-ic-scope')) customElements.define('vtbag-ic-scope', ICScope);
</script>
