import { namedElements, allRoots } from '@/css';
import { getElementSelector } from './element-selector';
import { nestGroups, numberGroupsDFS, type Group } from './group';
import { linkToParent, sort, type SparseDOMNode } from './sparse-dom';

const ids = new WeakMap<Element, string>();
let idCount = 0;

export function capture(transitionRoot: HTMLElement, groups: Map<string, Group>): string {
	let sheet = '';
	const seen = new Set<string>();
	const elementMap = new Map<Element, SparseDOMNode>();
	const sparseDOM: SparseDOMNode[] = [];

	const { elements: named } = namedElements(transitionRoot);
	allRoots.add(transitionRoot);
	const style = getComputedStyle(transitionRoot);
	let rootNode: SparseDOMNode = {
		viewTransitionName: 'none',
		element: transitionRoot,
		style,
		children: [],
	};
	elementMap.set(transitionRoot, rootNode);

	named.forEach(({ element, pseudoElement }) => {
		const path = getElementSelector(element);
		// todo element.dataset.vtbagIcId = path;
		const key = path + (pseudoElement ? pseudoElement : '');
		if (seen.has(key)) return;
		seen.add(key);

		const style = getComputedStyle(element, pseudoElement);
		if (style.viewTransitionName === 'none') return;
		if (style.display === 'none') return;

		const potentiallyRenamed = renameAutoGeneratedNames();
		//addBackLink();

		const node = {
			element,
			pseudoElement,
			viewTransitionName: potentiallyRenamed,
			viewTransitionGroup: style.viewTransitionGroup,
			viewTransitionClass: style.viewTransitionClass,
			style,
			children: [],
		};
		sparseDOM.push(node);
		if (!pseudoElement) elementMap.set(element, node);

		function renameAutoGeneratedNames() {
			const name = style.viewTransitionName;
			if (name === 'match-element' || (name === 'auto' && !element.id)) {
				let id = ids.get(element);
				if (!id) {
					id = `-vtbag-${name}-${++idCount}`;
					ids.set(element, id);
				}
				sheet += `${key} { view-transition-name: ${id} !important}\n`;
				return id;
			}
			return name;
		}

		function addBackLink() {
			const withBackLink =
				(style.backdropFilter !== 'none' ? style.backdropFilter + ' ' : '') +
				`url(#vtbag-ic-${key})`;
			sheet += `${key} { backdrop-filter: ${withBackLink}}\n`;
		}
	});

	rootNode = elementMap.get(transitionRoot)!;
	rootNode.paintGroup = rootNode.zIndex = 0;

	sparseDOM.forEach(linkToParent.bind(null, elementMap, transitionRoot));
	sort(rootNode);

	const groupRoot = groups.get('@')!;
	nestGroups(rootNode, groupRoot, groupRoot, groups);
	numberGroupsDFS(groupRoot);

	return sheet;
}
