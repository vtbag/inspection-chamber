---
import Pseudo from './Pseudo.astro';
import GroupList from './GroupList.astro';
import Identify from '@/components/ic/IdentifyPseudos.astro';
---

<Pseudo />
<GroupList />
<Identify />

<script>
	import {
		getCurrentViewTransition,
		mayStartViewTransition,
	} from '@vtbag/utensil-drawer/may-start-view-transition';
	import { deriveCSSSelector } from './element-selector';
	import { color, displayName, gid, type Group, isSorted, linear } from './group';
	import { highlight } from './highlight';
	import { ledGroup, type LEDs, showLedGroup, hideLedGroup } from './led-group';
	import { slider, setMaxValue, setCurrentValue } from './slider';
	import { addBlinds } from './blinds';
	import { frameToggles } from './multi-frame';
	import { ICElement } from './ic-element';
	import { HOW_IC_CALLS_MSVT_CATCH_ERRORS } from './debug';
	import type { Features } from './features';
	import { message } from './message';

	let nextId = 0;
	const scopeMap = new WeakMap<HTMLElement, number>();
	class ICScope extends ICElement {
		#scope: HTMLElement | null = null;
		#rootGroup: Group | undefined = undefined;
		#animations: Animation[] = [];
		#path: string | undefined = undefined;
		#dirty = false;
		#id = 0;
		#sortLEDs?: LEDs;
		#sizeLEDs?: LEDs;
		#freezeLEDs?: LEDs;
		#timings: Map<Animation, ComputedEffectTiming> = new Map();
		#longestDuration?: number;
		#clickTrack: Animation | undefined;
		#resizeObserver?: ResizeObserver;
		#resizeToggle: boolean = false;
		#animationsElement?: VtbagIcAnimationsElement;
		#frameToggleRefresh?: () => void;
		#raf?: number;
		#resynced: boolean = false;
		lastTimeChange: number = -1;

		tearDown() {
			this.#resizeObserver?.disconnect();
			this.#clickTrack?.cancel();
			this.#raf && cancelAnimationFrame(this.#raf);
			this.#raf = undefined;
		}

		connectedMoveCallback() {}

		setUp() {
			this.#resizeObserver = new ResizeObserver(() => {
				if (this.#resizeToggle || getCurrentViewTransition()) {
					return;
				}
				this.#resizeToggle = true;
				requestAnimationFrame(() => {
					addBlinds(this.querySelector('.scope-head')!, 'div', 'head-blind', 'shb', 'blind');
					this.#resizeToggle = false;
				});
			});
			this.#resizeObserver.observe(this);

			addEventListener('ic-time-change', async (e) => {
				const { element, time, origin } = (e as CustomEvent).detail;
				if (element !== this) return;
				setCurrentValue(`slider-${this.#id}`, time);
				if (origin === 'auto-move') return;
				this.animations.forEach(
					(a) =>
						(a as Animation & { 'vtbag-stopped'?: boolean })['vtbag-stopped'] ||
						(a.currentTime = time)
				);
			});
			addEventListener('ic-ready-error', (e) => {
				const {
					root,
					viewTransition: _viewTransition,
					features,
					error,
				} = (e as CustomEvent).detail as {
					root: HTMLElement;
					viewTransition: ViewTransition;
					features: Features;
					error: any;
				};
				if (root.ownerDocument.visibilityState !== 'visible')
					message('error', 'View transition skipped for hidden document. [ðŸ–¶]', [error]);

				let snapshotContainingBlockSizeChange = undefined;
				if (
					root === root.ownerDocument.documentElement &&
					(innerHeight != features.initialHeight || innerWidth != features.initialWidth)
				)
					snapshotContainingBlockSizeChange = Object.create({
						currentHeight: innerHeight,
						currentWidth: innerWidth,
						initialHeight: features.initialHeight,
						initialWidth: features.initialWidth,
					});
				if (root !== root.ownerDocument.documentElement) {
					const { width, height } = root.getBoundingClientRect();
					if (height != features.initialHeight || width != features.initialWidth)
						snapshotContainingBlockSizeChange = Object.create({
							currentHeight: height,
							currentWidth: width,
							initialHeight: features.initialHeight,
							initialWidth: features.initialWidth,
						});
				}
				if (snapshotContainingBlockSizeChange)
					message('error', 'View transition skipped due to viewport size change. [ðŸ–¶]', [
						snapshotContainingBlockSizeChange,
					]);
			});
		}

		get path() {
			return (this.#path ??= deriveCSSSelector(this.#scope!));
		}

		get scopeId() {
			return this.#id;
		}
		get element() {
			return this.#scope;
		}

		init(element: HTMLElement, root: Group, animations: Animation[]) {
			this.#scope = element;
			this.#rootGroup = root;
			this.#animations = animations;
			this.#path = undefined;
			this.#dirty = true;
			this.#id = scopeMap.get(element) ?? 0;
			if (!this.#id) {
				this.#id = ++nextId;
				scopeMap.set(element, this.#id);
			}

			this.#sortLEDs = {
				className: 'sort',
				groupName: `scope-sort-${this.#id}`,
				checked: 'paint-order',
				alternatives: [
					{
						label: 'Alphabetical',
						value: 'alpha',
						id: `scope-sort-${this.#id}-alpha`,
					},
					{
						label: 'Paint Order',
						value: 'paint-order',
						id: `scope-sort-${this.#id}-paint-order`,
					},
				],
			};
			this.#sizeLEDs = {
				className: 'size',
				independent: true,
				groupName: `scope-size-${this.#id}`,
				checked: 'none',
				alternatives: [
					{
						label: 'Compact',
						value: 'compact',
						id: `scope-size-${this.#id}-compact`,
					},
					{
						label: 'Detailed',
						value: 'detailed',
						id: `scope-size-${this.#id}-detailed`,
					},
				],
			};
			this.#freezeLEDs = {
				className: 'freeze',
				groupName: `freeze-${this.#id}`,
				checked: 'none',
				alternatives: [
					{
						label: 'Freeze',
						value: 'freeze',
						id: `freeze-${this.#id}`,
					},
					{
						label: 'Next',
						value: 'next',
						id: `next${this.#id}`,
					},
					{
						label: 'Run',
						value: 'run',
						id: `run-${this.#id}`,
					},
				],
			};
		}

		get animations() {
			return this.#animations;
		}
		set animations(value: Animation[]) {
			if (value.some((a) => !this.#animations.includes(a))) {
				this.#animations = [...new Set<Animation>([...this.#animations, ...value])];
				this.#dirty = true;
				this.render();
			}
		}

		animatedRender() {
			this.#animations.forEach((a) => a.pause());
			mayStartViewTransition!(
				{
					update: () => {
						this.render();
					},
					types: ['vt-entry'],
				},
				{
					useTypesPolyfill: 'always',
					collisionBehavior: 'chaining',
					catchErrors: HOW_IC_CALLS_MSVT_CATCH_ERRORS,
				}
			);
		}
		render() {
			if (this.isConnected && this.#dirty) {
				this.classList.add('panel');
				this.setAttribute('data-scope', this.path);

				this.#animationsElement = this.closest('vtbag-ic-animations')!;
				this.#dirty = false;
				let html = `
				<details class="scope" open>
					<summary class="secondary">Scope <span class="scope-path"><strong>${this.path}</strong></span></summary>
					<div class="scope-head"><div class="scope-head-main">
						<details class="groups"
						${sessionStorage.getItem('vtbag-ic-group-name-details') === 'true' ? 'open' : ''}
						><summary>Group names</summary>`;
				html += this.allGroupButtons(this.#rootGroup!, false);
				html += '</details></div>';
				html += slider(`slider-${this.#id}`, `slider-${this.#id}`);
				if (!isSorted(this.#rootGroup!)) {
					html += ledGroup(this.#sortLEDs!);
				}
				html += ledGroup(this.#sizeLEDs!);

				this.#freezeLEDs!.checked =
					this.#animationsElement!.querySelector<HTMLInputElement>(
						'.animations-head input[name="freeze"]:checked'
					)?.value ?? 'none';

				html += ledGroup(this.#freezeLEDs!);
				html += '</div></details>';

				this.innerHTML = html;
				const sizer = this.querySelector('.input-led-group.size')! as HTMLElement;
				const sorter = this.querySelector('.input-led-group.sort')! as HTMLElement;

				const groupNames = this.querySelector('details details') as HTMLDetailsElement;
				groupNames.addEventListener('toggle', () => {
					sessionStorage.setItem('vtbag-ic-group-name-details', groupNames.open.toString());
					if (groupNames.open) {
						showLedGroup(sorter);
					} else {
						hideLedGroup(sorter);
					}
				});

				this.#frameToggleRefresh = frameToggles(
					this.querySelector<HTMLDivElement>('div.scope-head')!,
					'vtbag-ic-scope',
					this.#id
				);
				this.addEventListener('frame-toggle', () => {
					this.#frameToggleRefresh!();
				});

				this.querySelectorAll<HTMLInputElement>(`input[name^="freeze"]`).forEach((e) =>
					e.classList.remove('orange', 'red')
				);
				if (this.querySelector<HTMLInputElement>(`input[value="next"]`)!.checked) {
					const input = this.querySelector<HTMLInputElement>(`input[value="freeze"]`)!;
					input.click();
					input.clientHeight;
				}

				if (this.querySelector<HTMLInputElement>(`input[value="freeze"]`)!.checked) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.add(
						'red'
					);
					this.animations.forEach((a) => {
						a.pause();
					});
				}

				this.#animationsElement!.updateAnimationsHead();
				this.updateScopeHead();

				this.querySelector('details')!.insertAdjacentHTML(
					'beforeend',
					`<details class="pseudos" 
						${sessionStorage.getItem('vtbag-ic-pseudo-details') === 'true' ? 'open' : ''}>
						<summary>Pick pseudo-elements from tree</summary>
						<vtbag-ic-pseudo name="::view-transition"></vtbag-ic-pseudo>
					</details>`
				);

				const pseudosDetails = this.querySelector('details.pseudos') as HTMLDetailsElement;
				const pseudoRoot = pseudosDetails.lastElementChild! as VtbagIcPseudoElement;
				const groupList = document.createElement('vtbag-ic-group-list') as VtbagIcGroupListElement;
				groupList.animations = this.animations;
				pseudoRoot.appendChild(groupList);

				pseudosDetails.addEventListener('toggle', () => {
					sessionStorage.setItem('vtbag-ic-pseudo-details', pseudosDetails.open.toString());
					if (pseudosDetails.open) {
						showLedGroup(sizer);
						showLedGroup(sorter);
					} else {
						hideLedGroup(sizer);
						hideLedGroup(sorter);
					}
				});
				const pseudos = [...this.querySelectorAll<VtbagIcPseudoElement>('vtbag-ic-pseudo')].sort(
					(a, b) => (a.icGroup?.group.preOrder ?? -1) - (b.icGroup?.group.preOrder ?? -1)
				);

				pseudos.forEach((pseudo) => pseudo.createTwin());
				pseudos.forEach((pseudo) => parent.__vtbag.ic2?.intersectionObserver?.observe(pseudo.twin));

				const error = (e: any) => console.error('View Transition error:', e, ' Cause:', e.cause);
				this.setupSlider();
				this.addSortListener(groupList, error);
				this.addResizeListener(error);
				this.addFreezeListener();
				this.addButtonListener();
				this.addDetailsListener();
				this.addEventListener('resync', () => this.resync());
			}
		}

		setupSlider() {
			this.#animations.forEach((a) => this.#timings.set(a, a.effect!.getComputedTiming()));
			const longestAnimation = this.#animations.reduce((a, b) =>
				this.#timings.get(a)!.endTime! > this.#timings.get(b)!.endTime! ? a : b
			);
			const current = this.#animations.reduce(
				(acc, other) => Math.min(acc, other.currentTime as number),
				Infinity
			);
			this.#longestDuration = this.#timings.get(longestAnimation)!.endTime! as number;
			const slowMo = this.#animationsElement!.querySelector<HTMLInputElement>(
				'input[name="slow-mo"]:checked'
			)?.value;
			this.#clickTrack = this.#scope?.animate([{ top: 0 }, { top: 0 }], {
				duration: this.#longestDuration,
				pseudoElement: '::view-transition',
				playbackRate: slowMo === 'normal' ? 1 : slowMo === 'slow' ? 0.1 : 0.01,
			})!;
			(this.#clickTrack as CSSAnimation & { 'vtbag-alias': string })['vtbag-alias'] =
				'vtbag-ic-click-track';
			this.#animations.push(this.#clickTrack);
			if (this.#animations[0].playState === 'paused') this.#clickTrack.pause();

			setMaxValue(
				`slider-${this.#id}`,
				this.#longestDuration,
				current, // this.#animations[0].currentTime as number, // todo: better minimum of all animations?
				(e) => {
					const time = parseInt((e.target as HTMLInputElement).value, 10);
					if (time !== this.lastTimeChange) {
						this.lastTimeChange = time;
						dispatchEvent(
							new CustomEvent('ic-time-change', {
								detail: { element: this, origin: 'scope-slider', time: this.lastTimeChange },
							})
						);
					}
				}
			);
			this.resync();
		}

		resync() {
			if (this.#resynced) return;
			this.#resynced = true;
			this.#animations
				.filter(
					(a) =>
						a.playState === 'paused' && a.effect?.pseudoElement?.startsWith('::view-transition')
				)
				.forEach((a) => {
					const now = a.currentTime;
					a.currentTime === 0 ? a.currentTime++ : (a.currentTime as number)--;
					requestAnimationFrame(() => {
						a.currentTime = now;
						this.#resynced = false;
					});
				});
		}

		updateScopeHead() {
			addBlinds(this.querySelector('.scope-head')!, 'div', 'head-blind', 'shb', 'blind');
			this.#frameToggleRefresh!();
		}

		private addButtonListener() {
			this.addEventListener('click', async (e) => {
				if ((e.target as HTMLElement).classList?.contains('group-content')) {
					(e.target as HTMLElement).lastElementChild?.classList.toggle('compact');
					return;
				}
				const button = (e.target as HTMLElement)?.closest('*[data-group]') as HTMLElement;
				if (!button) return;
				const id = button.dataset.group;
				const group =
					button.tagName !== 'BUTTON'
						? (this.querySelector<VtbagIcGroupElement>(
								`vtbag-ic-group:has(button[data-group="${id}"])`
							) ?? (this.querySelector('.scope-head-main') as HTMLDivElement))
						: this.querySelector<VtbagIcGroupElement>(`vtbag-ic-group:has(h3[data-group="${id}"])`);
				if (button.tagName === 'BUTTON') {
					const details = this.querySelector<HTMLDetailsElement>('details.pseudos')!;
					if (!details.open) {
						details.open = true;
						await new Promise((r) => setTimeout(r, 250));
					}
				}
				highlight(group);
			});
			this.addButtonEnterLeaveListeners();
		}

		private addDetailsListener() {
			this.addEventListener('click', async (e) => {
				const span = e.target as HTMLElement as HTMLSpanElement;
				if (span.tagName !== 'SPAN' || !span.classList.contains('name')) return;
				const pseudo = span.closest('vtbag-ic-pseudo') as VtbagIcPseudoElement;
				pseudo &&
					document
						.querySelector<VtbagIcPseudoDetailsElement>('vtbag-ic-pseudo-details')
						?.set(pseudo.dataset.link!);
			});
		}

		private addButtonEnterLeaveListeners() {
			['pointerenter', 'pointerleave'].forEach((name) =>
				this.querySelectorAll<HTMLButtonElement>('button[data-group]').forEach((b) =>
					b.addEventListener(name, (e) => {
						const button = e.target as HTMLButtonElement;
						if (button.tagName !== 'BUTTON') return;
						const id = button.dataset.group;
						if (!id) return;
						this.querySelector<VtbagIcGroupElement>(
							`vtbag-ic-group:has(h3[data-group="${id}"]) .frame input`
						)?.click();
					})
				)
			);
		}
		private addResizeListener(error: (e: any) => void) {
			this.querySelector('.input-led-group.size')?.addEventListener('change', () => {
				const compact = this.querySelector<HTMLInputElement>(`input[value="compact"]`)!.checked;
				const detailed = this.querySelector<HTMLInputElement>(`input[value="detailed"]`)!.checked;
				if (!detailed && !compact) return;

				const styles: string[] = [];
				document.querySelectorAll<VtbagIcGroupElement>('vtbag-ic-group').forEach((g) => {
					styles.push(`
::view-transition-group(${g.style.getPropertyValue('--vtn')}) {
--vtbag-ic-group-color: ${g.style.getPropertyValue('--vtbag-ic-group-color')};
	outline: ${g.style.outline};
	border-radius: 4px;	
}`);
				});
				document.head.insertAdjacentHTML(
					'beforeend',
					`
<style data-vtbag="size-vt">
${styles.join('\n')}
</style>`
				);

				const transition = mayStartViewTransition!(
					{
						update: () => {
							this.querySelectorAll<VtbagIcGroupElement>(
								'vtbag-ic-group vtbag-ic-pseudo[name="group"]'
							).forEach((pseudo) => pseudo.classList.toggle('compact', compact));
						},
						types: ['resize'],
					},
					{ useTypesPolyfill: 'always', catchErrors: HOW_IC_CALLS_MSVT_CATCH_ERRORS }
				);
				transition.updateCallbackDone.catch(error);
				transition.ready.catch(error);
				transition.finished.then(() => {
					document.head.querySelector('style[data-vtbag="size-vt"]')?.remove();
					this.querySelector<HTMLInputElement>('.input-led-group.size input:checked')?.click();
				});
			});
		}

		private addSortListener(groupList: VtbagIcGroupListElement, error: (e: any) => void) {
			this.querySelector('.input-led-group.sort')?.addEventListener('change', (e) => {
				this.#sortLEDs!.checked = (e.target as HTMLInputElement).value;
				const transition = mayStartViewTransition!(
					{
						update: () => {
							const alpha = this.querySelector<HTMLInputElement>(`input[value="alpha"]`)!.checked;
							groupList.sort(alpha ? 'alpha' : 'paint-order');
							const children = this.querySelector('.children')!;
							children.insertAdjacentHTML(
								'afterend',
								this.allGroupButtons(this.#rootGroup!, alpha)
							);
							const news = children.nextElementSibling as HTMLElement;
							children.remove();
							[...news.children].forEach((element) =>
								element.classList.toggle(
									'in-view',
									children
										.querySelector(`[data-group="${element.getAttribute('data-group')}"]`)
										?.classList.contains('in-view') ?? false
								)
							);
							this.addButtonEnterLeaveListeners();
						},
						types: ['sort'],
					},
					{ useTypesPolyfill: 'always', catchErrors: HOW_IC_CALLS_MSVT_CATCH_ERRORS }
				);
				transition.updateCallbackDone.catch(error);
				transition.ready.catch(error);
			});
		}

		private addFreezeListener() {
			this.querySelector('.input-led-group.freeze')?.addEventListener('change', (e) => {
				if ((e.target as HTMLElement)?.tagName !== 'INPUT') return;

				if (this.querySelector<HTMLInputElement>(`input[value="freeze"]:checked`)) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)?.classList.add(
						'red'
					);
					this.#animations.forEach((a) => a.pause());
				}
				if (this.#raf !== undefined) {
					cancelAnimationFrame(this.#raf);
					this.#raf = undefined;
				}
				if (this.querySelector<HTMLInputElement>(`input[value="run"]:checked`)) {
					this.#animationsElement
						?.querySelector<HTMLInputElement>('#reset-stopped-animations')
						?.click();

					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.remove(
						'red'
					);
					const speed = this.#animationsElement!.querySelector<HTMLInputElement>(
						'input[name="slow-mo"]:checked'
					)?.value;
					this.#animations.forEach((a) => {
						a.currentTime === this.#longestDuration && (a.currentTime = this.#longestDuration! - 1);
						a.playbackRate = speed === 'normal' ? 1 : speed === 'slow' ? 0.1 : 0.01;
						'vtbag-stopped' in a || a.play();
					});
					this.autoMoveSlider();
				}
				if (this.querySelector<HTMLInputElement>(`input[value="next"]:checked`)) {
					this.querySelector<HTMLInputElement>(`input[name^="freeze"]:checked`)!.classList.remove(
						'red'
					);
					this.#animations.forEach((a) => {
						a.finish();
					});
				}
				this.#animationsElement!.updateAnimationsHead();
			});
		}

		autoMoveSlider() {
			this.#raf = requestAnimationFrame(() => {
				const time = ~~this.#clickTrack!.currentTime!;
				if (time !== this.lastTimeChange) {
					this.lastTimeChange = time;
					setCurrentValue(`slider-${this.#id}`, time);
					dispatchEvent(
						new CustomEvent('ic-time-change', {
							detail: { element: this, origin: 'auto-move', time: this.lastTimeChange },
						})
					);
				}
				this.#raf && this.autoMoveSlider();
			});
		}

		allGroupButtons(rootGroup: Group, alpha = true, hide = false) {
			let html = `<div class="children" style="display:${hide ? 'none' : 'block'}">`;
			const buttons = linear(rootGroup); //[...rootGroup.children];

			if (alpha) {
				buttons.sort((a, b) =>
					a.name.replace(/^-vtbag-/, '').localeCompare(b.name.replace(/^-vtbag-/, ''))
				);
			}

			buttons.forEach((g) => {
				if (g.parent === undefined) return;
				const name = displayName(g);
				html += `<button data-group="${gid(g)}" style="--vtn: b-${this.#id}-${gid(g)}; border: 2px solid ${color(g)}">${name}</button>`;
			});
			html += '</div>';
			return html;
		}
	}


	if (!customElements.get('vtbag-ic-scope')) customElements.define('vtbag-ic-scope', ICScope);
</script>

<style is:global>
	@import './styles/details.css';
	@layer components {
		vtbag-ic-scope {
			display: block;
			padding-top: 0.5rem;
			border-top: 1px solid light-dark(#d0d080, #202080);
			border-right: 1px solid light-dark(#d0d080, #202080);
			details.scope {
				> summary {
					padding-left: 1.5rem;
					padding-bottom: 0.5rem;
					&::before {
						left: 0.5rem;
					}
				}
			}
			details.pseudos {
				> summary {
					padding-top: 1rem;
					padding-left: 2rem;
					&::before {
						top: 1rem;
						left: 1rem;
					}
				}
			}
		}
		.children {
			padding: 0.5rem 0;
		}

		vtbag-ic-pseudo[name="::view-transition"] > .pseudo-head {
			padding: 0 0.5rem 0.5rem 1rem;
		}
	}
</style>
