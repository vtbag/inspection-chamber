---
import Scope from './Scope.astro';
import './ic.css';
---

<Scope />
<template id="vtbag-ic-animations">
	<h2>Inspection Chamber</h2>
	<div style="display:flex">
		<div style="flex: 1 1 auto">
			<h3 class="heading" style="width: fit-content">Scopes:</h3>
			<select name="scope-select"></select>
		</div><div style="flex: 1 1 auto">
			<label for="freeze-toggle">Pause</label>
			<input type="checkbox" id="freeze-toggle" checked />
		</div>
	</div>
	<div class="scope-container container"></div>
</template>
<script>
	import { capture } from './capture';
	import { getElementSelector } from './element-selector';
	import { type Group, size } from './group';
	import { key } from './scope';

	const moduleGroupMaps = new Map<Element, Map<string, Group>>();

	class ICAnimations extends HTMLElement {
		#initialized = false;
		#throttleReRender = false;
		#globalAnimations: Animation[] = [];
		#scopes = new Map<HTMLElement, VtbagIcScopeElement>();
		groupMaps: Map<Element, Map<string, Group>>;

		constructor() {
			super();
			this.groupMaps = moduleGroupMaps;
		}
		connectedCallback() {
			if (this.#initialized) return;
			this.#initialized = true;

			this.appendChild(
				(document.getElementById('vtbag-ic-animations') as HTMLTemplateElement).content.cloneNode(
					true
				)
			);
			addEventListener('ic-after-capture-new', this.mayRender);
			addEventListener('ic-animation-change', this.mayRender);

			const freezeToggle = this.querySelector<HTMLInputElement>('#freeze-toggle')!;
			freezeToggle.addEventListener('change', () => {
				if (freezeToggle!.checked) {
					this.#globalAnimations.forEach((a) => a.pause());
				} else {
					this.#globalAnimations.forEach((a) => a.play());
				}
			});

			const scopeList = this.querySelector<HTMLSelectElement>('select[name="scope-select"]')!;

			scopeList.addEventListener('change', (e) => {
				const scope = [...this.#scopes.values()].find((s) => s.path === scopeList.value);
				if (scope) {
					scope.scrollIntoView({ behavior: 'smooth', block: 'start' });
				}
			});

			scopeList.addEventListener('pointerup', (e) => {
				const scope = [...this.#scopes.values()].find((s) => s.path === scopeList.value);
				if (scope) {
					scope.animate(
						[
							{ outline: '8px solid gray', offset: 0 },
							{ outline: '0 solid gray', offset: 1 },
						],
						{ delay: 300, duration: 200, easing: 'ease-in' }
					);
				}
			});
		}

		mayRender = (e: Event) => {
			let again = false;
			const detail = (e as CustomEvent).detail;
			const root = detail.root;
			if (detail.event?.type === 'animationend') {
				setTimeout(() => this.mayRender(new CustomEvent('recall', { detail: { root } })), 1);
				return;
			}
			if (this.#throttleReRender) {
				again = true;
				return;
			}
			requestAnimationFrame(() => {
				this.#throttleReRender = false;
				if (again) this.animatedRender(root);
			});
			this.#throttleReRender = true;
			this.animatedRender(root);
		};

		animatedRender(root: HTMLElement) {
			//mayStartViewTransition(() => this.render());
			this.render(root);
		}

		render(root: HTMLElement) {
			if (this.isConnected) {
				const select = this.querySelector('[name="scope-select"]')!;

				const newScopes = this.refreshAnimations(root.getAnimations({ subtree: true }));
				if (!newScopes) return;

				const scopeContainer = this.querySelector<HTMLDivElement>('div.scope-container')!;

				select.innerHTML = '';
				[...this.#scopes.values().map((s) => s.path)]
					.sort((a, b) => a.localeCompare(b))
					.forEach((path) =>
						select.insertAdjacentHTML('beforeend', `<option value="${path}">${path}</option>`)
					);

				let allScopesWeight = 0;
				const scopeRoots: Group[] = [];
				newScopes.forEach((_, scope) => {
					const root = this.groupMaps.get(key(scope))!.get('@')!;
					allScopesWeight += size(root);
					root.scope = scope;
					scopeRoots.push(root);
				});
				scopeRoots.sort((a, b) => size(b) - size(a));
				console.log('allScopes :>> ', allScopesWeight);
				scopeRoots.forEach((r) => console.log(r.scope!.id, size(r)));
				const rect =
					this.querySelector<HTMLDivElement>('.scope-container')!.getBoundingClientRect();
				console.log(rect.width, rect.height);

				[...scopeContainer.children]
					.sort((a, b) =>
						a.querySelector('span')!.innerText.localeCompare(b.querySelector('span')!.innerText)
					)
					.forEach((c) => scopeContainer.appendChild(c));
			}
		}
		refreshAnimations(animations: Animation[]) {
			const freezeToggle = this.querySelector<HTMLInputElement>('#freeze-toggle')!;

			if (freezeToggle.checked) {
				animations.forEach((a) => a.pause());
			}
			if (
				animations.length === this.#globalAnimations.length &&
				animations.every((a, i) => a === this.#globalAnimations[i])
			) {
				console.log('no change in global animations');
				return;
			}
			this.#globalAnimations = animations;

			const newScopes = new Map<HTMLElement, Animation[]>();
			animations.forEach((a) => {
				if (
					a.effect?.pseudoElement?.startsWith('::view-transition') &&
					// todo: deal with other types of animation
					a.effect?.target
				) {
					const scope = a.effect!.target!;
					let animations = newScopes.get(scope);
					if (!animations) {
						animations = [];
						newScopes.set(scope, animations);
					}
					animations.push(a);
				}
			});
			console.log('newScopes', newScopes);

			newScopes.forEach((animations, elem) => {
				this.refreshScope(elem, animations);
			});
			this.#scopes.forEach((scope, element) => {
				if (!newScopes.has(scope.element)) {
					scope.remove();
					this.#scopes.delete(element);
				}
			});
			return newScopes;
		}

		private refreshScope(element: HTMLElement, animations: Animation[]) {
			let scope = this.#scopes.get(key(element))!;
			if (!scope) {
				scope = document.createElement('vtbag-ic-scope');
				scope.init(element, this.groupMaps.get(key(element))!.get('@')!, animations);
				this.querySelector<HTMLDivElement>('div.scope-container')!.appendChild(scope);
				this.#scopes.set(key(element), scope);
			}
			if (
				scope.animations?.length !== animations.length ||
				scope.animations.some((a, i) => a !== animations[i])
			) {
				scope.animations = animations;
			}
		}
	}

	if (!customElements.get('vtbag-ic-animations'))
		customElements.define('vtbag-ic-animations', ICAnimations);

	['ic-before-capture-old', 'ic-before-capture-new'].forEach((event) =>
		top!.addEventListener(event, (e) => {
			const transitionRoot = (e as CustomEvent).detail.root;
			const transitionRootKey = key(transitionRoot);
			console.log(e.type, transitionRoot);
			const groups =
				e.type === 'ic-before-capture-old'
					? new Map<string, Group>([
							['@', { name: '@', className: '', children: [], ancestor: false }],
						])
					: moduleGroupMaps.get(transitionRootKey)!;
			const sheet = capture(transitionRoot, groups);
			moduleGroupMaps.set(transitionRootKey, groups);

			const head = transitionRoot.ownerDocument.head;
			head.insertAdjacentHTML(
				'beforeend',
				`<style id="vtbag-ic-temp-style-${CSS.escape(getElementSelector(transitionRoot))}">${sheet}</style>`
			);
		})
	);

	['ic-after-capture-old', 'ic-after-capture-new'].forEach((event) =>
		top!.addEventListener(event, (e) => {
			(e as CustomEvent).detail.root.ownerDocument.body
				.querySelector(`#vtbag-ic-temp-style-${CSS.escape(getElementSelector((e as CustomEvent).detail.root))}`)
				?.remove()
		})
	);

	top!.addEventListener('ic-before-capture-new', (e) =>
		(e as CustomEvent).detail.root.ownerDocument.body.insertAdjacentHTML(
			'beforeend',
			`
<style id="vtbag-ic-persistent-style">
	::view-transition-image-pair(*),
	::view-transition-old(*),
	::view-transition-new(*) {
	--vtbag-ic-only-child: initial;

}
	::view-transition-image-pair(*):only-child,
::view-transition-old(*):only-child,
::view-transition-new(*):only-child {
	--vtbag-ic-only-child: "1";
}
</style>
`
		)
	);
	top!.addEventListener('ic-about-to-finish', (e) =>
		(e as CustomEvent).detail.root.ownerDocument.body
			.querySelector('#vtbag-ic-persistent-style')
			?.remove()
	);
</script>
