import { namedElements, allRoots } from '@/css';
import { deriveCSSSelector } from './element-selector';
import { nestGroups, numberGroupsDFS, type Group } from './group';
import { linkToParent, sort, type SparseDOMNode } from './sparse-dom';
import { message } from './message';

const ids = new WeakMap<Element, string>();
let idCount = 0;

export const moduleGroupMaps = new Map<Element, Map<string, Group>>();

function capture(
	transitionRoot: HTMLElement,
	groups: Map<string, Group>,
	oldOrNew: 'old' | 'new'
): string {
	let sheet = '';
	const seen = new Set<string>();
	const elementMap = new Map<Element, SparseDOMNode>();
	const sparseDOM: SparseDOMNode[] = [];

	allRoots.add(transitionRoot);
	const { elements: named } = namedElements(transitionRoot);
	const style = getComputedStyle(transitionRoot);
	let rootNode: SparseDOMNode = {
		viewTransitionName: 'none',
		element: transitionRoot,
		style,
		children: [],
	};
	elementMap.set(transitionRoot, rootNode);

	named.forEach(({ element, pseudoElement }) => {
		const path = deriveCSSSelector(element);
		const key = path + (pseudoElement ? pseudoElement : '');
		if (seen.has(key)) return;
		seen.add(key);

		const style = getComputedStyle(element, pseudoElement);
		if (style.viewTransitionName === 'none') return;
		if (style.display === 'none') return;

		const potentiallyRenamed = renameAutoGeneratedNames();
		//addBackLink();

		const node = {
			element,
			pseudoElement,
			viewTransitionName: potentiallyRenamed,
			viewTransitionGroup: style.viewTransitionGroup,
			viewTransitionClass: style.viewTransitionClass,
			style,
			children: [],
		};
		sparseDOM.push(node);
		if (!pseudoElement) elementMap.set(element, node);

		function cssUnescape(str: string): string {
			return str
				.replace(/\\([0-9a-fA-F]{1,6})\s?/g, (_match, hex) => {
					return String.fromCharCode(parseInt(hex, 16));
				})
				.replace(/\\(.)/g, '$1');
		}
		function renameAutoGeneratedNames() {
			const name = cssUnescape(style.viewTransitionName);
			if (name === 'match-element' || (name === 'auto' && !element.id)) {
				let id = ids.get(element);
				if (!id) {
					id = `-vtbag-${name}-${++idCount}`;
					ids.set(element, id);
				}
				sheet += `${key} { view-transition-name: ${id} !important}\n`;
				return id;
			}
			return name;
		}

		function _addBackLink() {
			const withBackLink =
				(style.backdropFilter !== 'none' ? style.backdropFilter + ' ' : '') +
				`url(#vtbag-ic-${key})`;
			sheet += `${key} { backdrop-filter: ${withBackLink}}\n`;
		}
		if (0) _addBackLink();
	});

	rootNode = elementMap.get(transitionRoot)!;
	rootNode.paintGroup = rootNode.zIndex = 0;

	sparseDOM.forEach(linkToParent.bind(null, elementMap, transitionRoot));
	sort(rootNode);

	const groupRoot = groups.get('@')!;
	groupRoot[oldOrNew] = rootNode;
	if (nestGroups(rootNode, groupRoot, groupRoot, groups, oldOrNew)) {
		const capture = !!document.querySelector<HTMLInputElement>('#capture')?.checked;
		message('error',
			`<b>Duplicate</b> view transition <b>names</b> detected <b>during ${oldOrNew} capture</b>. ` + (capture ? `Check capture results below for details.` : `Enable <b>Analyze capturing</b> mode below to see details.`)
		);
	}
	numberGroupsDFS(groupRoot);

	return sheet;
}

['ic-before-capture-old', 'ic-before-capture-new'].forEach((eventName) =>
	self.addEventListener(eventName, (event) => {
		const detail = (event as CustomEvent).detail;
		const transitionRoot = detail.root;
		const crossDocument = detail.features.crossDocument;
		let groups;
		let sheet;

		if (eventName === 'ic-before-capture-old') {
			groups = new Map<string, Group>([
				['@', { name: '' + moduleGroupMaps.size, className: '', children: [], ancestor: false }],
			]);
			moduleGroupMaps.set(transitionRoot, groups);
			sheet = capture(transitionRoot, groups, 'old');
			if (crossDocument) {
				moduleGroupMaps.set(undefined!, groups);
				parent.__vtbag.ic2!.crossDocumentGroups = groups;
			}
		} else {
			if (crossDocument) {
				moduleGroupMaps.set(undefined!, parent.__vtbag.ic2!.crossDocumentGroups!);
				moduleGroupMaps.set(transitionRoot, moduleGroupMaps.get(undefined!)!);
			}
			groups = moduleGroupMaps.get(transitionRoot)!;
			sheet = capture(transitionRoot, groups, 'new');
		}

		const head = transitionRoot.ownerDocument.head;
		head.insertAdjacentHTML(
			'beforeend',
			`<style id="vtbag-ic-temp-style-${groups.get('@')!.name}">${sheet}</style>`
		);
	})
);

['ic-after-capture-old', 'ic-after-capture-new', 'ic-ready-error'].forEach((eventName) =>
	self.addEventListener(eventName, (event) => {
		const detail = (event as CustomEvent).detail;
		const root = detail.root;
		root.ownerDocument.head
			.querySelector(`#vtbag-ic-temp-style-${moduleGroupMaps.get(root)?.get('@')?.name}`)
			?.remove();
	})
);

self.addEventListener('ic-about-to-finish', (e) => {
	const transitionRoot = (e as CustomEvent).detail.root;
	moduleGroupMaps.delete(transitionRoot);
	allRoots.delete(transitionRoot);
	parent.__vtbag.ic2!.vtMap!.delete(transitionRoot);
	transitionRoot.ownerDocument.documentElement === transitionRoot &&
		parent.__vtbag.ic2!.vtMap!.delete(undefined!);
});
